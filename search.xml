<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CTA基础知识</title>
    <url>/2022/04/19/CTA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>本章旨在介绍CTA，以及相关的量化策略。</p>
<span id="more"></span>

<h1 id="1-什么是CTA？"><a href="#1-什么是CTA？" class="headerlink" title="1. 什么是CTA？"></a>1. 什么是CTA？</h1><p>商品交易顾问(Commodity Trading Advisor，简称CTA)是指通过为客户提供期货、期权方面的交易建议，或者通过受管理的期货账户参与实际交易，来获得收益的机构或个人。由于CTA的交易对象通常是商品期货和金融期货，所以<strong>CTA策略</strong>也被称作<strong>管理期货（Managed Futures）策略</strong>。</p>
<p>狭义上来说，CTA策略的研究对象只包括期货和期权，像国内的<strong>股指期货，大宗商品期货和国债期货</strong>（利率期货），这些品种是目前国内CTA策略的主要研究对象和利润来源。</p>
<p>广义上来说，可以是大宗商品期货，国债期货（利率期货），股票，外汇（包括spots和futures），甚至期权等任何有一定历史公开量价数据的品种。</p>
<p>国内CTA策略仍有巨大发展空间。截至2020年末，全球对冲基金行业管理的总资产为8263亿美元，其中管理期货（CTA）行业为3015亿美元。截至最新数据，目前国内私募中有6693只产品正在使用CTA策略，数量占比5.46%；而已披露数据显示该策略规模占整个私募行业1.09%。</p>
<img src="/2022/04/19/CTA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/number_rate.jpg" class="">

<img src="/2022/04/19/CTA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/money_rate.jpg" class="">

<h1 id="2-CTA的交易对象"><a href="#2-CTA的交易对象" class="headerlink" title="2. CTA的交易对象"></a>2. CTA的交易对象</h1><p>CTA策略的交易对象主要为期货和期权。</p>
<p>期货为是以现货为参照物，对其未来价格做出自己的判断，然后买入相对应的合约，约定未来可以以合约约定的价格卖出或者买入所对应的合约标的。</p>
<p>CTA策略交易标的主要分为两种，分别为商品期和金融期货。常见的投资标的如下：</p>
<ul>
<li>商品期货：（1）农产品期货：大豆、豆油、豆粕、小麦、玉米、棉花、白糖等。（2）金属期货：铜、铝、铅、锌、镍等有色金属和黄金、白银等贵金属。（3）能源期货：原油、燃料油等。（4）黑色期货：螺纹钢、焦炭、铁矿石、螺纹钢等。（5）化工期货：天然橡胶、PTA、PVC、甲醇等。</li>
<li>金融期货：（1） 国债期货：2年期国债期货、5年期国债期货、10年期国债期货。（2） 股指期货：沪深300股指期货（IF）、中证500股指期货（IC）上证50股指期货（IH）</li>
</ul>
<p>与期货相比国内能交易的期权品种相对较少。金融期权有50etf期权，沪深300etf期权和沪深300指数期权。商品期权分布在国内的四家期权交易所，比如上海期货交易所（铜、橡胶期权等）、大连商品交易所（铁矿石、豆粕期权等）、郑州商品交易所（棉花、白糖期权等）、上海国际能源交易中心（天然气期权）。</p>
<p><strong>Tips：什么是期权？</strong></p>
<blockquote>
<p>期权又称为选择权，是一种衍生性金融工具。是指买方向卖方支付<a href="http://www.yhqh.net/html/172-30/30811.htm">期权费</a>（指<a href="http://www.yhqh.net/html/172-30/30811.htm">权利金</a>）后拥有的在未来一段时间内（指<a href="http://www.yhqh.net/html/172-30/30935.htm">美式期权</a>）或未来某一特定日期（指<a href="http://www.yhqh.net/html/172-30/30935.htm">欧式期权</a>）以事先规定好的价格（指履约价格）向卖方购买或出售一定数量的特定商品的权利，但不负有必须买进或卖出的义务（即期权买方拥有选择是否行使买入或卖出的权利，而期权卖方都必须无条件服从买方的选择并履行成交时的允诺）。</p>
</blockquote>
<h1 id="3-CTA策略子策略分类"><a href="#3-CTA策略子策略分类" class="headerlink" title="3. CTA策略子策略分类"></a>3. CTA策略子策略分类</h1><ul>
<li><strong>人或者机器的判断逻辑可以分为主观CTA或者量化CTA</strong></li>
</ul>
<p>主观CTA：基于人的判断，管理人基于基本面，主观判断走势，非常考验基金管理人基于基本面、调研或操盘经验，主观来判断走势，决定买卖时点，以及出现失误时能否迅速做出调整。</p>
<p>量化CTA：基于机器的判断，基金管理人通过分析建立数量化的交易策略模型，由模型产生的买卖信号进行投资决策，人的错误判断对量化CTA的干扰比较小。量化CTA也需要长期对数据的分析、参数的优化、模型的更新迭代，这个过程和量化选股很类似。</p>
<ul>
<li><strong>略分类可以分为趋势跟踪、趋势反转、套利对冲</strong></li>
</ul>
<p>趋势跟踪：主要通过追随已形成的价格趋势获利，在上涨趋势时持有多仓，下跌时持有空仓，当趋势结束时平仓。</p>
<p>趋势反转：通过价格拐点从价格回归过程中获利。信号反转向上时持有多仓，显示价格反转向下时持有空仓，实现回归时进行平仓。</p>
<p>套利对冲：通过对相关品种/合约进行交易。可以做多低估值品种，做空高估值品种；也可以从价格回归中获利，包括期现套利、跨期套利、跨品种套利、跨市场套利等。</p>
<blockquote>
<p>狭义上来说，传统的CTA策略都是趋势追随策略。白话来说，就是追涨杀跌。文绉绉来说，就是价格的时间序列存在系数为正的自相关关系。这类策略能挣钱的逻辑有这么几种，1是投资者对盈利和亏损比例的容忍程度是不对称的；2是当趋势不断延续时，随着做多和做空双方投资者PNL比例的增加，投资者更容易出现非理性行为，尤其是亏损的一方容易互相践踏平仓；3是价格的returns概率分布本身就是一个很大的肥尾。</p>
<p>趋势追随策略通常胜率会比较低，而每笔交易的盈亏比会比较大，白话来说，就是亏小钱，挣大钱。没行情的时候亏小钱，有行情的时候赚大钱。市场给机会就吃一口，没机会就熬啊熬，熬啊熬。历史上多少CTA基金就是这样被熬死的，倒在了黎明前的黑暗。</p>
<p>广义上来说，CTA策略应该是趋势追踪策略为主，反转策略为辅。就像前面所说的，趋势追踪策略容易死在黎明前，为了避免这点，或者说为了让自己更赖操，就需要一些在没行情的日子里也能喝口汤的策略，这类策略就是反转策略。和趋势追踪相关，反转策略白话来说，就是高抛低吸；文绉绉来说，就是价格的时候序列存在系数为负的自相关关系。很多人会问，价格的时间序列不是非正即负吗，怎么会又正相关，又负相关？这个问题在这儿暂时就不回答了，后续在更新。不过可以肯定告诉大家的就是这个问题的答案值个10万块钱应该没啥问题。趋势策略好写，总体都是类似的。幸福的家庭（趋势策略）都是相似的,每个不幸的家庭（反转策略）都有各自的不幸（反转）。</p>
</blockquote>
<ul>
<li><strong>持仓周期策略又可以分为长周期、中周期、短周期、高频。</strong></li>
</ul>
<p>长周期：两周及以上，最长可达数月；波动大。</p>
<p>中周期：1-2周，波动较大。</p>
<p>短周期：5个交易日内，波动较小。高频：几秒到一天不等，比较稳健（俗称期货期权不过夜）。</p>
<h1 id="4-CTA策略风险调整后收益和股票相关性"><a href="#4-CTA策略风险调整后收益和股票相关性" class="headerlink" title="4.CTA策略风险调整后收益和股票相关性"></a>4.CTA策略风险调整后收益和股票相关性</h1><p>很多人一提及CTA就会联想到期货合约较高的杠杆，认为CTA策略具有较高的风险，对其敬而远之。事实上刚好相反，CTA是相当稳健的投资策略。CTA策略因为多空转换灵活，在熊市的时候也能转向空头，套取收益，所以产品能得到较好的控制，性价比较好。</p>
<p>另外，因期货具有在极端市场行情下表现更佳的特质，与股票相关性系数低，与股票搭配在一起可以组成非常好的资产配置方案。</p>
<p><strong>优点一：CTA策略具备较好的风险收益比</strong></p>
<p>CTA策略具备比较稳健的收益和比较小的回撤。</p>
<p>我们统计了市场上近五年数据披露比较全的CTA基金，组成了一只组合，发现CTA近五年回报64%，可以超越中证500和沪深300。投资者可以体会一下。</p>
<img src="/2022/04/19/CTA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/CTA_returns.jpg" class="">

<p>另外，CTA组合的回撤明显长期小于A股两大指数，统计数据显示组合最大回撤仅为12.04%，小于中证500的40.11%，沪深300的32.46%。下面是它们的动态回撤图：</p>
<img src="/2022/04/19/CTA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/CTA_withdraw.jpg" class="">

<p><strong>优点二：CTA策略与股票相关性系数低</strong></p>
<p>有研究表明合约市场（期货、期权、远期等）在极端行情下表现较为突出，因此与股票市场具有较弱相关性。因此通过将风险分散到各个品种，可以获得强势的风险调整后收益。</p>
<img src="/2022/04/19/CTA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/CTA_corr.jpg" class="">

<p>近五年来，中证500与沪深300指数相关性系数较强，而CTA组合与两大指数之间的相关性系数较弱，<strong>CTA与股票是非常好的组合策略。</strong></p>
]]></content>
      <categories>
        <category>基金知识</category>
      </categories>
      <tags>
        <tag>CTA知识</tag>
        <tag>量化策略</tag>
      </tags>
  </entry>
  <entry>
    <title>基金基础知识</title>
    <url>/2022/02/20/%E5%9F%BA%E9%87%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>本章节旨在介绍基金的相关知识，包含基金分类方法，买卖成本，各种基金购买方法等方面。</p>
<span id="more"></span>

<h3 id="1-基金分类方法"><a href="#1-基金分类方法" class="headerlink" title="1 基金分类方法"></a>1 基金分类方法</h3><h4 id="1-1-按照投资品种分类"><a href="#1-1-按照投资品种分类" class="headerlink" title="1.1 按照投资品种分类"></a>1.1 按照投资品种分类</h4><ul>
<li><p><strong>股票型基金</strong>：①80%以上的资产投资于股票。②收益最高。③风险最大。</p>
</li>
<li><p><strong>混合型（偏股，偏债）基金</strong>：①一般股票60%，债券20%，货币20%。②收益率比债券基金高。③风险也比债券基金高。</p>
</li>
<li><p><strong>债券型基金</strong>：①80%以上的资产投资于债券。②收益率比货币基金高。③风险也比货币基金高。</p>
</li>
<li><p><strong>货币型基金</strong>：①基金资产仅投资于货币市场（银行存单，央票等）。②收益率较低，但是比活期存款高。③风险相对较小。</p>
<img src="/2022/02/20/%E5%9F%BA%E9%87%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/risk_profit.jpg" class=""></li>
</ul>
<h4 id="1-2-按照投资方式分类"><a href="#1-2-按照投资方式分类" class="headerlink" title="1.2 按照投资方式分类"></a>1.2 按照投资方式分类</h4><ul>
<li><strong>被动性基金（指数基金）</strong>：按照构成指数的成分股配置。申购费比较低。</li>
<li><strong>主动型基金</strong>：由基金经理来选股，选债。申购费较高</li>
</ul>
<h4 id="1-3-基金运作方式分类"><a href="#1-3-基金运作方式分类" class="headerlink" title="1.3 基金运作方式分类"></a>1.3 基金运作方式分类</h4><ul>
<li><strong>开放式基金</strong>：随时可以买入或者卖出</li>
<li><strong>封闭式基金</strong>：封闭期内基金份额不变，必须在证券交易场购买（场内购买）。</li>
</ul>
<h4 id="1-4-按购买渠道分类"><a href="#1-4-按购买渠道分类" class="headerlink" title="1.4 按购买渠道分类"></a>1.4 按购买渠道分类</h4><ul>
<li><strong>场内基金</strong>：放在证券交易所里买卖的基金。操作起来与买卖股票是一样的。例如同花顺，东方财富等平台。</li>
<li><strong>场外基金</strong>：在证券交易所外买卖的基金。</li>
</ul>
<p>  ​    两者有以下几个区别：</p>
<p>①<strong>是否需要证券交易账户：</strong>场内交易需要证券账户，场外交易不需要设置证券账户。</p>
<p>②<strong>交易价格：</strong>场内基金的交易与股票类似，实时买入卖出。场外基金一天只有一个价格。如果在下午三点前买入，则按照当日交易结束时的价格结算。三点后购买，按照第二个交易日结束时价格结算。</p>
<p>③<strong>交易费率不同：</strong>场内交易费率便宜。场外交易申购（0.1%-0.15%）赎回（0.2%-1.5%），平均综合费率，万分之30-165。场内交易跟股票一样，交易佣金根据券商决定。</p>
<p>④<strong>委托方式：</strong>场内叫做买入卖出，场外叫做申购赎回。</p>
<p>⑤<strong>交易和到账时间不同：</strong>场内交易跟股市一直，当天买入，下一工作日可以卖出。</p>
<p>⑥<strong>品种多样性：</strong>场外基金品种更丰富，场内不一定包含了所有基金品种。</p>
<img src="/2022/02/20/%E5%9F%BA%E9%87%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/in_out_funds.png" class="">

<h3 id="2-晨星星级评定"><a href="#2-晨星星级评定" class="headerlink" title="2 晨星星级评定"></a>2 晨星星级评定</h3><p>  晨星网的评级反映了一只基金能给投资者带来的<strong>回报与自身风险</strong>之间的关系。对购买基金有较好的参考作用。</p>
  <img src="/2022/02/20/%E5%9F%BA%E9%87%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/morningstar.jpg" class="">

<h3 id="3-基金买卖过程中的成本"><a href="#3-基金买卖过程中的成本" class="headerlink" title="3 基金买卖过程中的成本"></a>3 基金买卖过程中的成本</h3><p>  ​    基金购买过程的费用主要包含四种：<strong>申购费、赎回费、管理费、托管费</strong>。不同的购买渠道，费用相差比较大。下面介绍几种购买方式：</p>
<ul>
<li><p>银行代销：<strong>货币型基金</strong>没有申购费，债券型基金申购费0.6%-0.8%。<strong>股票型基金</strong>1%-1.5%。</p>
</li>
<li><p>基金公司：申购费常常打折。基金转换时只需要补申购费差价。但是只能购买本基金公司的产品。</p>
</li>
<li><p>第三方基金代销平台：常见的有天天基金，支付宝等。申购费最低，品种比较齐全。</p>
<img src="/2022/02/20/%E5%9F%BA%E9%87%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/funds_fee.jpg" class="">

<p>可以看到，管理费，托管费在净值公布时就已经扣除了。赎回的费率一般时间越长费率越低。大多数情况下，申购费一般会打一折甚至免费。下图列出了不同类型基金的费用。</p>
<img src="/2022/02/20/%E5%9F%BA%E9%87%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/fees.jpg" class=""></li>
</ul>
<h3 id="4-评价基金的指标"><a href="#4-评价基金的指标" class="headerlink" title="4 评价基金的指标"></a>4 评价基金的指标</h3><h4 id="4-1-策略总收益（Total-Returns）"><a href="#4-1-策略总收益（Total-Returns）" class="headerlink" title="4.1 策略总收益（Total Returns）"></a>4.1 策略总收益（Total Returns）</h4><p>$$<br>\text { Total Returns }=\frac{P V_{\text {end }}-P V_{\text {start }}}{P V_{\text {start }}} * 100<br>$$</p>
<p>$PV_{end}$：最终总价值</p>
<p>$PV_{start}$：开始总价值</p>
<h4 id="4-2-年化收益率（Annualized-Returns）"><a href="#4-2-年化收益率（Annualized-Returns）" class="headerlink" title="4.2 年化收益率（Annualized Returns）"></a>4.2 年化收益率（Annualized Returns）</h4><p>策略年化收益率。表示投资期限为一年的预期收益率。<br>$$<br>\text { Total Annualized Returns }=R_{p}=\left((1+P)^{\frac{252}{n}}-1\right) * 100<br>$$<br>$P$：策略总收益</p>
<p>$n$：策略执行天数</p>
<h4 id="4-3-波动率（Volatility）"><a href="#4-3-波动率（Volatility）" class="headerlink" title="4.3 波动率（Volatility）"></a>4.3 波动率（Volatility）</h4><p>  基金投资回报率的波动程度，体现为策略每日收益的年化标准差 。<br>$$<br>\text { Volatility }=\sigma_{p}=\sqrt{\frac{252}{n} \sum_{i}^{n}\left(R_{p}-\overline{R_{p}}\right)^{2}}<br>$$<br>$R_p$：策略总收益</p>
<p>$\overline{R_{p}}$：策略每日收益率平均值</p>
<p>$n$：策略执行天数</p>
<h4 id="4-4-最大回撤（Max-Drawdown）"><a href="#4-4-最大回撤（Max-Drawdown）" class="headerlink" title="4.4 最大回撤（Max Drawdown）"></a>4.4 最大回撤（Max Drawdown）</h4><p>基金收益率回撤幅度的最大值。描述策略可能出现的最糟糕的情况。</p>
<p>$$<br>\text { Max Drawdown }=\frac{\operatorname{Max}\left(P_{x}-P_{y}\right)}{P_{x}}<br>$$<br>$P_x,P_y$：某日总价值，且$y&gt;x$</p>
<h4 id="4-5-夏普比率（Sharpe-Ratio）"><a href="#4-5-夏普比率（Sharpe-Ratio）" class="headerlink" title="4.5 夏普比率（Sharpe Ratio）"></a>4.5 夏普比率（Sharpe Ratio）</h4><p>投资光看收益是不够的，还要看承受的风险，也就是收益风险比。夏普比率描述的正是这个概念，即每承受一单位的总风险，会产生多少超额的报酬。用数学公式描述就是：<br>$$<br>\text { Sharpe Ratio }=\frac{\left(R_{p}-R_{f}\right)}{\sigma_{p}}<br>$$<br>$R_{p}$：投资组合预期收益率（各种年化利率）</p>
<p>$R_f$：无风险利率（十年期国债利率，或默认0.03）</p>
<p>$\sigma_{p}$：年化波动率</p>
<h4 id="4-6-信息比率（Information-Ratio）"><a href="#4-6-信息比率（Information-Ratio）" class="headerlink" title="4.6 信息比率（Information Ratio）"></a>4.6 信息比率（Information Ratio）</h4><p>衡量单位超额风险带来的超额收益。信息比率越大，说明该策略单位跟踪误差所获得的超额收益越高，因此，信息比率较大的策略的表现要优于信息比率较低的基准。合理的投资目标应该是在承担适度风险下，尽可能追求高信息比率。<br>$$<br>\text { Sharpe Ratio }=\frac{\left(R_{p}-R_{m}\right)}{\sigma_{t}}<br>$$<br>$R_{p}$：投资组合预期收益率（各种年化利率）</p>
<p>$R_m$：基准年化收益率</p>
<p>$\sigma_{t}$：策略与基准每日收益差值的年化标准差</p>
<h4 id="4-7-阿尔法（Alpha）"><a href="#4-7-阿尔法（Alpha）" class="headerlink" title="4.7 阿尔法（Alpha）"></a>4.7 阿尔法（Alpha）</h4><p>投资中面临着系统性风险（即Beta）和非系统性风险（即Alpha），Alpha 是投资者获得与市场波动无关的回报。比如投资者获得了15%的回报，其基准获得了10%的回报，那么Alpha 或者价值增值的部分就是5%。<br>$$<br>\text { Alpha }=\alpha=R_{p}-\left(R_{f}+\beta_{p}\left(R_{m}-R_{f}\right)\right)<br>$$<br>$R_{p}$：策略年化收益率</p>
<p>$R_m$：基准年化收益率（？？）</p>
<p>$R_f$：无风险利率（十年期国债，或者默认0.03）</p>
<p>$\beta_{p}$：策略Beta值</p>
<p>Alpha值解释</p>
<p>α&gt;0 策略相对于市场，获得了超额收益<br>α=0 策略相对于市场，获得了适当收益<br>α&lt;0 策略相对于市场，获得了较少收益</p>
<h4 id="4-8-贝塔（Beta）"><a href="#4-8-贝塔（Beta）" class="headerlink" title="4.8 贝塔（Beta）"></a>4.8 贝塔（Beta）</h4><p>表示投资的系统性风险，反映了策略对大盘变化的敏感性。例如一个策略的Beta为1.5，则大盘涨1%的时候，策略可能涨1.5%，反之亦然；如果一个策略的Beta为-1.5，说明大盘涨1%的时候，策略可能跌1.5%，反之亦然。<br>$$<br>\operatorname{Beta}=\beta_{p}=\frac{\operatorname{Cov}\left(D_{p}, D_{m}\right)}{\operatorname{Var}\left(D_{m}\right)}<br>$$<br>$D_{p}$：策略每日收益率</p>
<p>$D_m$：基准每日收益率（？？）</p>
<p>$Cov(D_p,D_m)$：策略每日收益与基准每日收益的协方差</p>
<p>$Var{D_m}$：基准每日收益的方差</p>
<p>Beta值解释</p>
<p>β&lt;0 投资组合和基准的走向通常反方向，如空头头寸类</p>
<p>β=0 投资组合和基准的走向没有相关性，如固定收益类</p>
<p>0&lt;β&lt;1 投资组合和基准的走向相同，但是比基准的移动幅度更小</p>
<p>β=1 投资组合和基准的走向相同，并且和基准的移动幅度贴近</p>
<p>β&gt;1 投资组合和基准的走向相同，但是比基准的移动幅度更大</p>
<h3 id="5-基金特性"><a href="#5-基金特性" class="headerlink" title="5 基金特性"></a>5 基金特性</h3><h4 id="5-1-货币基金"><a href="#5-1-货币基金" class="headerlink" title="5.1 货币基金"></a>5.1 货币基金</h4><p>货币型基金安全性高，基本投资于银行，短债等收益稳定的领域。其次它的流动性好，例如余额宝等能够做到实时转入转出。然后是它的成本比较低，没有申购赎回费用，且管理费用也很低。最后它基本没有投资们开，起购金额低。</p>
<img src="/2022/02/20/%E5%9F%BA%E9%87%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/huobi_yinhang.jpg" class="">

<p><strong>什么样的货币基金值得买？</strong></p>
<p>一般来说，购买或货币基金考虑以下几个方面：<br>① 收益率：货币基金一般参考万份收益率和七天年化收益率。优先购买收益率高的。<br>② 购买规模适中：考虑到船大难掉头，一般来说中等规模（50-300亿，2018年数据。）的货币基金收益率最高。<br>③ 基金安全性：基金中散户比例高的流动性非常低，因此比较稳健。购买时散户比例最好不好低于20%。<br>④ 成立时间：较新的基金数据时间较短数据参考价值不高，而能够横穿牛熊的老牌基金更有参考价值，更为稳健。一般成立时间3-5年以上的比较好。</p>
<p><strong>申购赎回注意项</strong></p>
<p>①周五不买入，周四不赎回。尽量在下午三点前操作。<br>②节假日货币基金也有收益，可以提前申购。<br>③货币基金在同一家基金公司可以转换成股票基金或者混合基金。转换只收取申购赎回的差额费用。</p>
<h4 id="5-2-债券基金"><a href="#5-2-债券基金" class="headerlink" title="5.2 债券基金"></a>5.2 债券基金</h4><p><strong>债券的类别</strong></p>
<ul>
<li><strong>政府债券</strong>：比如中央政府发行的债券，叫国债。</li>
<li>金融机构债券：比如银行向社会发行的债券叫做金融债。信用比企业信用高。</li>
<li><strong>企业债券</strong>：企业自己发行的债券，信用没有前两个高。<br>债券的灵活性极差，购买后想卖出需要找到买家。</li>
</ul>
<p><strong>债券基金</strong></p>
<p>建议长期持有，存在亏损可能。收益率一般在5%以下。</p>
<img src="/2022/02/20/%E5%9F%BA%E9%87%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/bonds.jpg" class="">

<p>** 什么样的债券基金值得买？**</p>
<ul>
<li>收益率高低。</li>
<li>基金公司是否是大公司。（银行系的基金公司可能拿到成本更低的债券，名字例如工银瑞信双利债券A）</li>
<li>晨星评级。</li>
<li>购买基金时的费用。</li>
<li>基金规模最好在50-500亿</li>
</ul>
<p><strong>什么时候适合投资债券基金？</strong></p>
<ul>
<li>降息降准。货币政策宽松能促进债券型基金收益上升。</li>
<li>股市低迷。股票市场进入熊市时，债券基金收益较好</li>
</ul>
<h4 id="5-3-混合型基金与股票型基金"><a href="#5-3-混合型基金与股票型基金" class="headerlink" title="5.3 混合型基金与股票型基金"></a>5.3 混合型基金与股票型基金</h4><p>混合型基金分为四类：偏股型，偏债型，平衡型和配置型。从字面意思就能看出来各种类型的风险和收益。股票型基金要求股票占比必须在80%以上。风险和收益都是最高的。</p>
<p><strong>什么样的混合型基金值得买？</strong></p>
<p><strong>粗看：</strong></p>
<p>一般来说挑选混合型基金可以看以下几个流程挑选出3-5只基金：</p>
<p>①先看收益率。先海选三年累计收益率排名前30。再选5只近一年收益率相对较高的。</p>
<p>②选择大公司。比如易方达，博时，南方，嘉实等。</p>
<p>③挑选星级评定4-5星的。</p>
<p>④基金规模在20-150亿之间的，成立时间3-5年的。</p>
<p>⑤从基金经理挑选，具备3-5年管理经验的。</p>
<p>⑥购买费率较低的。</p>
<p><strong>细看</strong>：</p>
<p>①基金经理的能力。混合型基金属于主动型基金，比较考验基金经理的主动投资管理能力。可以从基金经理的星级，综合评分（经验值，收益率，抗风险，稳定性，择时能力等），任期收益等三方面看。</p>
<h3 id="6-指数基金"><a href="#6-指数基金" class="headerlink" title="6 指数基金"></a>6 指数基金</h3><p><strong>指数基金</strong>按照是否同吃各行各业分为两种：</p>
<ul>
<li><p><strong>宽基指数基金：</strong>沪深300，上证50，中证500，恒生指数，标普500等。</p>
</li>
<li><p><strong>行业指数基金：</strong>上证消费80，中证医疗指数，中证白酒指数。</p>
<p>基金名称中的ETF的全称是 Exchange Traded Fund，中文翻译称之为「交易型开放式<strong>指数</strong>基金」，又称「交易所交易基金」代表场内基金，ETF联结代表场外基金。</p>
<p>LOF的英⽂全称是”Listed Open-Ended Fund”，汉语称为“上市型开放式基⾦”。也就是上市 </p>
<p>型开放式基⾦发⾏结束后，投资者既可以在指定⽹点申购与赎回基⾦份额，也可以在交易所买 </p>
<p>卖该基⾦。也就是说我们既可以在交易所也可以在第三⽅机构购买LOF。</p>
</li>
</ul>
<h4 id="6-1-指数基金如何选择？"><a href="#6-1-指数基金如何选择？" class="headerlink" title="6.1 指数基金如何选择？"></a>6.1 指数基金如何选择？</h4><p>① 选择想要投资的指数。</p>
<p>选择一个代表性强且主流的指数即可。可以结合自己的偏好或者根据行情来决定。</p>
<p>② 选择靠谱的基金公司。</p>
<p>选择规模大的基金公司，资金充裕，服务也好。</p>
<p>③ 根据基金的指标挑选。</p>
<p>主要指标有：跟踪误差率、基金规模、成立年限以及费用成本。</p>
<p><strong>跟踪误差率</strong>低，说明基金运作水平高，误差风险小。<strong>规模</strong>越大则流动性越强，如果基金规模较小则基金清盘概率比较大。<strong>成立年限</strong>最好选择超过三年的，时间太短不足以评估基金。<strong>购买费率</strong>越低越好。</p>
<h4 id="6-2-市净率，市盈率"><a href="#6-2-市净率，市盈率" class="headerlink" title="6.2 市净率，市盈率"></a>6.2 市净率，市盈率</h4><h5 id="6-2-1-什么是市净率，市盈率？"><a href="#6-2-1-什么是市净率，市盈率？" class="headerlink" title="6.2.1 什么是市净率，市盈率？"></a>6.2.1 什么是市净率，市盈率？</h5><ul>
<li><p>市盈率（PE，Price–Earnings Ratio）</p>
<p>指的是一笔钱投资进一只股票需要多长时间回本。公式如下：<br>$$<br>PE=\frac{市值}{净利润}<br>$$<br>举个例子：</p>
<p>假设目前一个公司市值是100e人民币，上一年净利润是10e人民币，则PE=100/10=10倍，也就是说十年回本。</p>
</li>
<li><p>市净率（PB，Price-Book Value）</p>
<p>指的是公司净资产是否被低估。</p>
</li>
</ul>
<p>$$<br>PB=\frac{市值}{净资产}<br>$$</p>
<h5 id="6-2-2-市盈、市净率使用方法"><a href="#6-2-2-市盈、市净率使用方法" class="headerlink" title="6.2.2 市盈、市净率使用方法"></a>6.2.2 市盈、市净率使用方法</h5><ul>
<li>一般通过指数当前市盈，市净的<strong>历史百分位</strong>来判断估值情况，越被低估投资性价比越高。</li>
<li>指数市盈率：指的是<strong>指数成分股总市值</strong>除以<strong>指数成分股净利润总额</strong>，是衡量<strong>指数价格与收益关系的指标</strong>。指标越高代表着估值高，指标越低代表估值低。</li>
<li>指数市净率：指的是<strong>指数成分股总市值</strong>除以<strong>指数成分股净资产</strong>，是衡量<strong>指数价格与净资产关系的指标</strong>。指标越高代表着估值高，指标越低代表估值低。</li>
<li>市盈率（市净率）百分位：指的是统计指数所有历史数据，把目前的市盈率在历史上进行衡量判断，分析目前指数估值在历史中所处的位置。</li>
</ul>
<img src="/2022/02/20/%E5%9F%BA%E9%87%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/pb-pe.png" class="">

<h3 id="7-基金投资方式"><a href="#7-基金投资方式" class="headerlink" title="7 基金投资方式"></a>7 基金投资方式</h3><h4 id="7-1-一次性投资"><a href="#7-1-一次性投资" class="headerlink" title="7.1 一次性投资"></a>7.1 一次性投资</h4><p>顾名思义，一次性买入选定的基金。简单省事，但是当基金下跌时可操作空间较小。无法补仓。</p>
<h4 id="7-2-不定期投资（择时投资）"><a href="#7-2-不定期投资（择时投资）" class="headerlink" title="7.2 不定期投资（择时投资）"></a>7.2 不定期投资（择时投资）</h4><p>3月买4w，8月买6w等。缺点：择时太难，时间不确定，不能持久。</p>
<h4 id="7-3-定投"><a href="#7-3-定投" class="headerlink" title="7.3 定投"></a>7.3 定投</h4><p>定投是每隔固定时间，以固定金额，长期买入并持有基金产品。</p>
<p>好处：</p>
<p>①避免主观情绪干扰，不用每天都盯着股市</p>
<p>②平坦成本，倘若股市一直下跌，不断买入平坦了下跌的成本。</p>
<p>③先下跌后上涨的走势能够赚到超额利润。</p>
<h5 id="7-3-1-定期定额投资"><a href="#7-3-1-定期定额投资" class="headerlink" title="7.3.1 定期定额投资"></a>7.3.1 定期定额投资</h5><p>雷打不动，定期定额投资。缺点：收益会打折扣，无法根据大行情调整金额。</p>
<h5 id="7-3-2定期不定额投资"><a href="#7-3-2定期不定额投资" class="headerlink" title="7.3.2定期不定额投资"></a>7.3.2定期不定额投资</h5><p>在便宜的时候多买，贵的时候少买入。这样长期坚持下，同样的本金能够购买到更多的基金份额。</p>
<p>在一些软件上有<strong>智能定投</strong>的选项也就是，处于低估值的时候投入平时的1.5倍或者2倍，在高估值时投入一半的金额。</p>
<h3 id="8-如何止盈？"><a href="#8-如何止盈？" class="headerlink" title="8 如何止盈？"></a>8 如何止盈？</h3><p>会买是徒弟，会卖才是真厉害。因此要学会止盈。</p>
<h4 id="8-1-最小预期收益率法"><a href="#8-1-最小预期收益率法" class="headerlink" title="8.1 最小预期收益率法"></a>8.1 最小预期收益率法</h4><p>明确预期的目标收益率，实现目标收益率就卖出。目标止盈率的设置有以下几个原则：</p>
<ol>
<li><p>必须要跑赢通货膨胀。</p>
</li>
<li><p>设置期望最低超额收益率，起码要比货币基金要高。</p>
</li>
<li><p>以上两项相加就是期望的最小预期收益率。</p>
<p>无视行情，达到目标就止盈有点可惜。</p>
</li>
</ol>
<h4 id="8-2-分批止盈"><a href="#8-2-分批止盈" class="headerlink" title="8.2 分批止盈"></a>8.2 分批止盈</h4><p>指数估值水平是反应低估或者高估的重要指标，可以根据<strong>估值水平</strong>确定止盈线。</p>
<p>例如中证500指数，可以在PE为60、70和80时，分别分批卖出持有份额的50%，30%和20%。</p>
<p>例如沪深300指数，可以在PE为20、30和50时，分别分批卖出持有份额的50%，30%和20%。</p>
<p>止盈原则：</p>
<ul>
<li><p>不要追求卖在最高点，分批止盈为佳。</p>
</li>
<li><p>早期不用止盈，在中后期要分批止盈。</p>
</li>
<li><p>止盈套路很多，选择适合自己的。</p>
</li>
<li><p>尽量<strong>定投止盈不止损</strong></p>
</li>
<li><p>可以设置最大回撤止损线</p>
</li>
</ul>
<h4 id="8-4-调整基金组合"><a href="#8-4-调整基金组合" class="headerlink" title="8.4 调整基金组合"></a>8.4 调整基金组合</h4><p>当股市发生震荡时或者当基金业绩，投资目标改变时，可以考虑调整基金组合。</p>
<h3 id="9-定投指数组合"><a href="#9-定投指数组合" class="headerlink" title="9 定投指数组合"></a>9 定投指数组合</h3><p>分散风险，结合多板块，蓝筹，中小盘兼顾。不要把鸡蛋放在同一个篮子里。金字塔形的投资组合比较考验实操能力，难度较大，灵活性强。</p>
<img src="/2022/02/20/%E5%9F%BA%E9%87%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/invest_ratio.png" class="">

<p>设置投资目标时候需要考虑的因素包括：</p>
<img src="/2022/02/20/%E5%9F%BA%E9%87%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/invest_index.png" class="">

<h3 id="10-参考投资比例"><a href="#10-参考投资比例" class="headerlink" title="10 参考投资比例"></a>10 参考投资比例</h3><p>① <strong>保值型</strong></p>
<p>适合<strong>风险承受能力低</strong>，以<strong>保值为目标</strong>的人。其资金的分配比例，将<strong>半数或以上</strong>的资金用于 </p>
<p><strong>债券型基金</strong>的投资，并预留部分资金大约**20%**作为现金使用,而将一小部分资金（一般不超 </p>
<p>过**10%**）投入股票型基金、混合型基金等有较大风险的基金类别</p>
<p>② <strong>保守型</strong></p>
<p>适合<strong>风险承受能力低</strong>，期望资金可以<strong>小幅增值</strong>的人。其资金的分配比例，现金预留**10%**， </p>
<p>股票型基金占<strong>20%<strong>，混合型基金占</strong>10%左右</strong>，货币基金占<strong>10%到20%<strong>，债券基金占</strong>40%到50%</strong></p>
<p>③ <strong>平衡型</strong></p>
<p>适用于<strong>可承受一定风险、期望资金可以较快增长</strong>的投资者。其资金分配比例为：现金预留 </p>
<p><strong>0%-10%，</strong>股票型基金占<strong>30%-40%，</strong>混合型基金占<strong>10%-20%，</strong>货币市场基金占<strong>0%，</strong>债券型基金 </p>
<p>占<strong>40%-50%</strong></p>
<p>④ <strong>成长型</strong></p>
<p>适用于<strong>可承受较高风险、期望资金可以快速增长</strong>的投资者。其资金分配比例为：现金预留 </p>
<p><strong>0%-10%，</strong>股票型基金占<strong>40%左右，</strong>混合型基金占<strong>10%-20%，</strong>货币市场基金占<strong>0%，</strong>债券型基金 </p>
<p>占<strong>40%左右</strong></p>
<p>⑤ <strong>进取型</strong></p>
<p>适用于<strong>可承受高风险，期望资金可以显著增长</strong>的投资者。其资金分配比例为：现金预留 </p>
<p><strong>0%-10%<strong>，股票型基金占</strong>50%以上</strong>，混合型基金占<strong>10%左右</strong>，货币市场基金占**0%**，债券型基金 </p>
<h4 id="占30-左右"><a href="#占30-左右" class="headerlink" title="占30%左右"></a>占<strong>30%左右</strong></h4>]]></content>
      <categories>
        <category>基金知识</category>
      </categories>
      <tags>
        <tag>基金类型</tag>
        <tag>基金购买方法</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下库文件查看依赖的方法</title>
    <url>/2022/01/18/Windows%E4%B8%8B%E5%BA%93%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E4%BE%9D%E8%B5%96%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在Windows上有时候自己编译的EXE或者DLL文件会出现打不开的情况，一个可能的原因是文件缺乏依赖库。网上搜了一下都是推荐 <code>dumpbin</code> 命令，但是这个命令一方面是需要下载Visual Studio，很麻烦，另一方面没有GUI，而且看不到缺哪些库，很难受。还有推荐<code>Depend</code>的，我找了一下，现在Depend已经不更新了，只支持到Win8，在Win10上会卡死。</p>
<span id="more"></span>

<p>这里推荐一个好用的工具叫<code>Dependencies_x64</code>，下载链接<code>https://github.com/lucasg/Dependencies/releases</code></p>
<img src="/2022/01/18/Windows%E4%B8%8B%E5%BA%93%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E4%BE%9D%E8%B5%96%E7%9A%84%E6%96%B9%E6%B3%95/dependencies.png" class="">

<img src="/2022/01/18/Windows%E4%B8%8B%E5%BA%93%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E4%BE%9D%E8%B5%96%E7%9A%84%E6%96%B9%E6%B3%95/dependencies_qglopm.png" class="">

<p>对于库文件的依赖都列在左上角了，然后对于有问题的依赖，或是没找到的依赖都会标红处理。</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Debug</tag>
        <tag>依赖查看</tag>
      </tags>
  </entry>
  <entry>
    <title>AirSim仿真之Python实现无人机控制</title>
    <url>/2022/01/17/AirSim%E4%BB%BF%E7%9C%9F%E4%B9%8BPython%E5%AE%9E%E7%8E%B0%E6%97%A0%E4%BA%BA%E6%9C%BA%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>Python实现AirSim控制</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> airsim</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> pynput <span class="keyword">import</span> keyboard</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QGridLayout, QMainWindow, QAction, QApplication, QWidget, QPushButton, qApp, QLabel, QHBoxLayout, QVBoxLayout, QSplitter</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QIcon, QPixmap, QImage, QMatrix4x4, QQuaternion, QVector3D, QColor, QGuiApplication</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> Qt,QTimer</span><br><span class="line"><span class="keyword">import</span> pyqtgraph <span class="keyword">as</span> pg</span><br><span class="line"><span class="keyword">from</span> pyqtgraph <span class="keyword">import</span> functions <span class="keyword">as</span> fn</span><br><span class="line"><span class="keyword">import</span> pyqtgraph.opengl <span class="keyword">as</span> gl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vel_map=&#123;</span><br><span class="line">            Qt.Key_Left : np.array((<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>)),</span><br><span class="line">            Qt.Key_Right: np.array((<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>)),</span><br><span class="line">            Qt.Key_Up   : np.array((<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)),</span><br><span class="line">            Qt.Key_Down : np.array((-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)),</span><br><span class="line">            Qt.Key_W    : np.array((<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>)),</span><br><span class="line">            Qt.Key_S    : np.array((<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">v_max = <span class="number">100</span>     <span class="comment"># 无人机最大飞行速度</span></span><br><span class="line">v_factor = <span class="number">15</span></span><br><span class="line">r_max = <span class="number">20</span>    <span class="comment"># 邻居选择的半径</span></span><br><span class="line">k_sep = <span class="number">7</span>     <span class="comment"># 控制算法系数</span></span><br><span class="line">k_coh = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">fov_degree = <span class="number">90</span></span><br><span class="line">height = <span class="number">144</span></span><br><span class="line">width = <span class="number">256</span></span><br><span class="line">cx = width/<span class="number">2</span></span><br><span class="line">cy = height/<span class="number">2</span></span><br><span class="line">f = height/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize</span>(<span class="params">v</span>):</span></span><br><span class="line">    norm = np.linalg.norm(v)</span><br><span class="line">    <span class="keyword">if</span> norm &lt; <span class="number">0.00000001</span>: </span><br><span class="line">       <span class="keyword">return</span> v</span><br><span class="line">    <span class="keyword">return</span> v / norm</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">np2qpixmap</span>(<span class="params">np_img</span>):</span></span><br><span class="line">    frame = cv2.cvtColor(np_img, cv2.COLOR_BGR2RGB)</span><br><span class="line">    img = QImage(frame, frame.shape[<span class="number">1</span>], frame.shape[<span class="number">0</span>], QImage.Format_RGB888)</span><br><span class="line">    <span class="keyword">return</span> QPixmap.fromImage(img)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiUAVControl</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MultiUAVControl, self).__init__()</span><br><span class="line">        self.client = airsim.MultirotorClient()</span><br><span class="line">        self.uav_names = self.client.listVehicles()</span><br><span class="line">        self.uav_num = <span class="built_in">len</span>(self.uav_names)</span><br><span class="line">        self.fname  = self.uav_names[-<span class="number">1</span>]</span><br><span class="line">        self.cur_UAV = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getUAVPos</span>(<span class="params">self,vehicle_name=<span class="string">&quot;SimpleFlight&quot;</span></span>):</span></span><br><span class="line">        state = self.client.simGetObjectPose(vehicle_name)</span><br><span class="line">        x = state.position.x_val</span><br><span class="line">        y = state.position.y_val</span><br><span class="line">        z = state.position.z_val</span><br><span class="line">        pos = np.array([x, y,z])</span><br><span class="line">        <span class="keyword">return</span> pos</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setCurUAV</span>(<span class="params">self,uav</span>):</span></span><br><span class="line">        <span class="keyword">if</span> uav &lt;= self.uav_num:</span><br><span class="line">            self.cur_UAV=uav</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">takeOff</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;start to takeoff&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> self.uav_names:</span><br><span class="line">            self.client.enableApiControl(<span class="literal">True</span>, name) </span><br><span class="line">            self.client.armDisarm(<span class="literal">True</span>, name)        </span><br><span class="line">            self.client.takeoffAsync(vehicle_name=name)</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> self.uav_names:</span><br><span class="line">            self.client.moveToZAsync(-<span class="number">3</span>, <span class="number">1</span>, vehicle_name=name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">land</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;start to land&quot;</span>)</span><br><span class="line">        self.client.simPause(<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> self.uav_names:</span><br><span class="line">            self.client.landAsync(vehicle_name=name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveByKeys</span>(<span class="params">self, keys</span>):</span></span><br><span class="line">        base_vel = np.array((<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> keys:</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">in</span> vel_map:</span><br><span class="line">                base_vel+=vel_map[k]</span><br><span class="line">        <span class="keyword">if</span>  np.linalg.norm(base_vel)  &lt;= <span class="number">0.00001</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> name <span class="keyword">in</span> self.uav_names:</span><br><span class="line">                pos_i = self.getUAVPos(name)</span><br><span class="line">                v_mig = v_factor* (base_vel <span class="keyword">if</span> self.cur_UAV == <span class="number">0</span> <span class="keyword">or</span> name == self.uav_names[self.cur_UAV-<span class="number">1</span>] <span class="keyword">else</span> np.zeros(<span class="number">3</span>))</span><br><span class="line">                v_sep = np.zeros(<span class="number">3</span>)</span><br><span class="line">                v_coh = np.zeros(<span class="number">3</span>)</span><br><span class="line">                neighbor = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> name_other <span class="keyword">in</span> self.uav_names:</span><br><span class="line">                    <span class="keyword">if</span> name != name_other:</span><br><span class="line">                        pos_j = self.getUAVPos(name_other)</span><br><span class="line">                        <span class="keyword">if</span> np.linalg.norm(pos_j - pos_i) &lt; r_max:</span><br><span class="line">                            neighbor = neighbor+<span class="number">1</span></span><br><span class="line">                            r_ij = pos_j - pos_i</span><br><span class="line">                            v_sep += -k_sep * r_ij / np.linalg.norm(r_ij)</span><br><span class="line">                            v_coh += k_coh * r_ij</span><br><span class="line">                v_sep = v_sep / <span class="built_in">max</span>(neighbor,<span class="number">1</span>)</span><br><span class="line">                v_coh = v_coh / <span class="built_in">max</span>(neighbor,<span class="number">1</span>)</span><br><span class="line">                vel = v_sep + v_coh + v_mig</span><br><span class="line">                vel = normalize(vel)*<span class="built_in">min</span>(np.linalg.norm(vel),v_max)</span><br><span class="line">                <span class="built_in">print</span>(vel)</span><br><span class="line">                self.client.moveByVelocityBodyFrameAsync(vel[<span class="number">0</span>], vel[<span class="number">1</span>],vel[<span class="number">2</span>],</span><br><span class="line">                                                         <span class="number">0.1</span>,drivetrain = airsim.DrivetrainType.ForwardOnly,</span><br><span class="line">                                                         yaw_mode=airsim.YawMode(is_rate=<span class="literal">False</span>,yaw_or_rate=<span class="number">0</span>),</span><br><span class="line">                                                         vehicle_name=name)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getImage</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        data = self.client.simGetImages([airsim.ImageRequest(<span class="number">0</span>, airsim.ImageType.Scene, <span class="literal">False</span>, <span class="literal">False</span>)],vehicle_name=name)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> np.flipud(np.frombuffer(data.image_data_uint8, dtype=np.uint8).reshape((data.height,data.width,<span class="number">3</span>)))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDepth</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        data = self.client.simGetImages([airsim.ImageRequest(<span class="number">0</span>, airsim.ImageType.DepthPerspective, <span class="literal">True</span>, <span class="literal">False</span>)],vehicle_name=name)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> np.array(data.image_data_float, dtype=np.float32).reshape((data.height,data.width))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDepthAndImage</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        data = self.client.simGetImages([airsim.ImageRequest(<span class="number">0</span>, airsim.ImageType.Scene, <span class="literal">False</span>, <span class="literal">False</span>),</span><br><span class="line">            airsim.ImageRequest(<span class="number">0</span>, airsim.ImageType.DepthPerspective, <span class="literal">True</span>, <span class="literal">False</span>) ],vehicle_name=name)</span><br><span class="line">        image = np.flipud(np.frombuffer(data[<span class="number">0</span>].image_data_uint8, dtype=np.uint8).reshape((data[<span class="number">0</span>].height,data[<span class="number">0</span>].width,<span class="number">3</span>)))</span><br><span class="line">        depth = np.array(data[<span class="number">1</span>].image_data_float, dtype=np.float32).reshape((data[<span class="number">1</span>].height,data[<span class="number">1</span>].width))</span><br><span class="line">        <span class="keyword">return</span> [image,depth]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getImages</span>(<span class="params">self</span>):</span></span><br><span class="line">        images = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> self.uav_names:</span><br><span class="line">            images[name]=self.getImage(name)</span><br><span class="line">        <span class="keyword">return</span> images</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDepthes</span>(<span class="params">self</span>):</span></span><br><span class="line">        images = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> self.uav_names:</span><br><span class="line">            images[name]=self.getDepth(name)</span><br><span class="line">        <span class="keyword">return</span> images</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPointCloudPos</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        data = self.getDepth(name)</span><br><span class="line">        poses=[]</span><br><span class="line">        <span class="keyword">for</span> (x,y),v <span class="keyword">in</span> np.ndenumerate(data):</span><br><span class="line">             poses.append([(x-cx)/f*v,(y-cy)/f*v,v])</span><br><span class="line">        <span class="keyword">return</span> np.array(poses)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPointCloudColor</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        data = self.getImage(name)</span><br><span class="line">        <span class="keyword">return</span> data.reshape((-<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPointCloud</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        [image,depth] = self.getDepthAndImage(name)</span><br><span class="line">        poses=[]</span><br><span class="line">        <span class="keyword">for</span> (x,y),v <span class="keyword">in</span> np.ndenumerate(depth):</span><br><span class="line">             poses.append([(x-cx)/f*v,(y-cy)/f*v,v])</span><br><span class="line">        image = cv2.cvtColor(image,cv2.COLOR_RGB2BGR)</span><br><span class="line">        colors=image.reshape((-<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        <span class="keyword">return</span> [np.array(poses),np.array(colors)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveToPositionAll</span>(<span class="params">self,x, y, z, velocity, </span></span></span><br><span class="line"><span class="params"><span class="function">        timeout_sec=<span class="number">3e+38</span>, drivetrain=<span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">        lookahead=-<span class="number">1</span>, adaptive_lookahead=<span class="number">1</span></span>):</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> self.uav_names:</span><br><span class="line">            <span class="keyword">if</span> name != self.fname:                                  </span><br><span class="line">                self.client.moveToPositionAsync(x, y, z,velocity, timeout_sec=timeout_sec, drivetrain=drivetrain,</span><br><span class="line">        lookahead=lookahead, adaptive_lookahead=adaptive_lookahead, vehicle_name=name)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.client.moveToPositionAsync(x, y, z,velocity, timeout_sec=timeout_sec, drivetrain=drivetrain,</span><br><span class="line">        lookahead=lookahead, adaptive_lookahead=adaptive_lookahead, vehicle_name=name).join()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveByVelocityAll</span>(<span class="params">self,vx, vy, vz, duration, drivetrain=<span class="number">0</span></span>):</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> self.uav_names:</span><br><span class="line">            self.moveByVelocityAsync(vx,vy,vz,duration,drivetrain=drivetrain,vehicle_name=name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveByVelocityOne</span>(<span class="params">self,vx, vy, z, duration, drivetrain=<span class="number">0</span></span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span>(<span class="params">QMainWindow</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.setWindowTitle(<span class="string">&#x27;MyScreen&#x27;</span>)</span><br><span class="line">        self.cur_key = <span class="built_in">set</span>()</span><br><span class="line">        self.uav_control = MultiUAVControl()</span><br><span class="line">        self.func_map=&#123;</span><br><span class="line">            Qt.Key_F : self.uav_control.takeOff,</span><br><span class="line">            Qt.Key_L : self.uav_control.land,</span><br><span class="line">        &#125;</span><br><span class="line">        self.vel_map=&#123;</span><br><span class="line">            Qt.Key_Left : np.array((<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>)),</span><br><span class="line">            Qt.Key_Right: np.array((<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>)),</span><br><span class="line">            Qt.Key_Up   : np.array((<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)),</span><br><span class="line">            Qt.Key_Down : np.array((-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)),</span><br><span class="line">            Qt.Key_W    : np.array((<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>)),</span><br><span class="line">            Qt.Key_S    : np.array((<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        self.initUI()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initUI</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        main_widget =QWidget()</span><br><span class="line">        layout = QGridLayout()</span><br><span class="line">        main_widget.setLayout(layout)</span><br><span class="line">        self.setCentralWidget(main_widget)</span><br><span class="line"></span><br><span class="line">        self.label = QLabel(self)</span><br><span class="line">        self.label.setFocusPolicy(Qt.FocusPolicy.ClickFocus)</span><br><span class="line">        layout.addWidget(self.label, <span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        glViewer = gl.GLViewWidget()</span><br><span class="line">        self.pcdData = gl.GLScatterPlotItem(size=<span class="number">1</span>)</span><br><span class="line">        glViewer.addItem(self.pcdData)</span><br><span class="line">        layout.addWidget(glViewer, <span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        self.timer = QTimer(self) </span><br><span class="line">        self.timer.timeout.connect(self.doMove)</span><br><span class="line">        self.timer.start(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_image</span>(<span class="params">self</span>):</span></span><br><span class="line">        (poses, colors) = self.uav_control.getPointCloud(<span class="string">&#x27;UAV1&#x27;</span>)</span><br><span class="line">        colors = colors/<span class="number">255</span></span><br><span class="line">        colors = np.insert(colors,<span class="number">3</span>,<span class="number">1</span>,axis=<span class="number">1</span>)</span><br><span class="line">        self.pcdData.setData(pos=poses,color=colors)</span><br><span class="line">        v_images = []</span><br><span class="line">        images_map = self.uav_control.getImages()</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> images_map.items():</span><br><span class="line">            v=v.copy()</span><br><span class="line">            v=cv2.putText(v,k,(<span class="number">10</span>,v.shape[<span class="number">0</span>]//<span class="number">2</span>),cv2.FONT_HERSHEY_SIMPLEX,<span class="number">1.2</span>,(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>),<span class="number">2</span>)</span><br><span class="line">            v_images.append(v)</span><br><span class="line">        v_img = cv2.vconcat(v_images)</span><br><span class="line">        pixmap = QPixmap(np2qpixmap(v_img))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pixmap.isNull():</span><br><span class="line">            self.label.setPixmap(pixmap)</span><br><span class="line">            self.label.adjustSize()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doMove</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.uav_control.moveByKeys(self.cur_key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">keyPressEvent</span>(<span class="params">self, event</span>):</span></span><br><span class="line">        key = event.key()</span><br><span class="line">        <span class="keyword">if</span> key == Qt.Key_Escape:</span><br><span class="line">            self.timer.stop()</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.vel_map:</span><br><span class="line">            self.cur_key.add(key)</span><br><span class="line">        <span class="keyword">elif</span> key &gt;= Qt.Key_0 <span class="keyword">and</span> key &lt;= Qt.Key_9:</span><br><span class="line">            self.uav_control.setCurUAV(key-Qt.Key_0)</span><br><span class="line">        <span class="keyword">elif</span> key <span class="keyword">in</span> self.func_map:</span><br><span class="line">            self.func_map[key]()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">keyReleaseEvent</span>(<span class="params">self, event</span>):</span></span><br><span class="line">        key=event.key()</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.vel_map:</span><br><span class="line">            self.cur_key.remove(key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    ex = App()</span><br><span class="line">    ex.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AirSim仿真</category>
      </categories>
      <tags>
        <tag>仿真</tag>
        <tag>Simulation</tag>
      </tags>
  </entry>
  <entry>
    <title>AirSim仿真之创建自己的仿真环境</title>
    <url>/2022/01/17/AirSim%E4%BB%BF%E7%9C%9F%E4%B9%8B%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>本章旨在使用UE创建自己的仿真环境<br>请参考<a href="https://microsoft.github.io/AirSim/unreal_custenv/">https://microsoft.github.io/AirSim/unreal_custenv/</a></p>
]]></content>
      <categories>
        <category>AirSim仿真</category>
      </categories>
      <tags>
        <tag>仿真</tag>
        <tag>Simulation</tag>
      </tags>
  </entry>
  <entry>
    <title>AirSim仿真之Windows环境搭建</title>
    <url>/2022/01/17/AirSim%E4%BB%BF%E7%9C%9F%E4%B9%8BWindows%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>本文旨在介绍AirSim在Windows下的环境配置流程。</p>
<span id="more"></span>

<h1 id="1-AirSim环境要求"><a href="#1-AirSim环境要求" class="headerlink" title="1. AirSim环境要求"></a>1. AirSim环境要求</h1><ul>
<li>在开始前先把以下环境配置好<ul>
<li>Windows 10+</li>
<li>Python 3.7+</li>
<li>Visual Studio 2019</li>
<li>CMake 3.9+</li>
<li>Epic Game Launcher</li>
</ul>
</li>
<li>AirSim<ul>
<li>Doc：<a href="https://microsoft.github.io/AirSim/">https://microsoft.github.io/AirSim/</a></li>
<li>Github: <a href="https://github.com/microsoft/AirSim">https://github.com/microsoft/AirSim</a></li>
<li>Environment: <a href="https://github.com/Microsoft/AirSim/releases">https://github.com/Microsoft/AirSim/releases</a></li>
</ul>
</li>
</ul>
<h1 id="2-安装虚幻引擎"><a href="#2-安装虚幻引擎" class="headerlink" title="2. 安装虚幻引擎"></a>2. 安装虚幻引擎</h1><ol>
<li>从<a href="https://www.unrealengine.com/download">Epic</a>官网下载新版的Epic客户端。下载完之后需要注册E宝账号。E宝的游戏促销力度很大，经常会免费送游戏，值得一下。</li>
<li>打开Epic，选中左侧的虚幻引擎（UnrealEngine ，UE）标签，再点击右侧的安装，选中<code>4.25版</code>安装。虽然有些仿真景观对UE版本有要求，但是实际上并不严格，不同版本也能兼容。</li>
</ol>
<img src="/2022/01/17/AirSim%E4%BB%BF%E7%9C%9F%E4%B9%8BWindows%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/epic_game.png" class="">

<h1 id="3-编译-AirSim"><a href="#3-编译-AirSim" class="headerlink" title="3. 编译 AirSim"></a>3. 编译 AirSim</h1><ol>
<li><p>将Windows升级到最新更新版。</p>
</li>
<li><p>下载AirSim。从 <a href="https://github.com/Microsoft/AirSim/releases">https://github.com/Microsoft/AirSim/releases</a> 中下载1.6.0版本的AirSim for windows。并解压到某一路径。</p>
</li>
<li><p>打开<code>Developer Command Prompt for VS 2019</code>，cd到刚刚解压的目录下，输入 build.cmd 。这里程序会自动从GitHub上下载<code>rpclib</code>和<code>car_assets</code>两个文件，若是下载失败可以手动下载然后移动到相应位置。</p>
<ul>
<li><p><a href="https://github.com/rpclib/rpclib/archive/v2.2.1.zip">点击此处获得rpclib地址</a></p>
</li>
<li><p><a href="https://github.com/Microsoft/AirSim/releases/download/v1.2.0/car_assets.zip">点击此处获得car_assets地址</a></p>
<p>将手动下载的<code>rpclib-2.2.1</code>重命名为 <code>rpclib.zip</code> 扔到 <code>external\rpclib.zip</code> 下。解压 <code>car_assert.zip</code> 的 <code>SUV</code> 文件夹到 <code>Unreal\Plugins\AirSim\Content\VehicleAdv\</code>。最后重新运行<code>build.cmd</code>。</p>
</li>
</ul>
</li>
<li><p>顺利的话，此时AirSim源码已经编译成功了。</p>
</li>
</ol>
<h1 id="4-测试Block环境"><a href="#4-测试Block环境" class="headerlink" title="4. 测试Block环境"></a>4. 测试Block环境</h1><p>本节参考 <a href="https://zhuanlan.zhihu.com/p/267321662">https://zhuanlan.zhihu.com/p/267321662</a></p>
<p>block环境是airsim自带嵌入的一个Unreal工程文件，可以测试Unreal和airsim是否安装配置成功。打开 “Developer Command Prompt for VS 2019”，进入 “Airsim\Unreal\Environments\Blocks” 文件夹下。进入文件夹的指令是 <code>CD Airsim\Unreal\Environments\Blocks</code>。然后运行指令 <code>update_from_git.bat</code>。运行完成之后，会在 “Airsim\Unreal\Environments\Blocks” 文件夹下生成 “Blocks.sln” 工程文件，如下图所示，双击打开此工程文件，会自动运行 Visual Studio 2019。</p>
   <img src="/2022/01/17/AirSim%E4%BB%BF%E7%9C%9F%E4%B9%8BWindows%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/blocks.jpg" class="">

<p>在Visual Studio 2019中，将 “Block工程” 设为启动项目，编译选项设为 “DebugGame_Editor” 和 “Win64”，然后点击 “调试” -&gt; “开始调试”，如下图所示，这时就会打开Unreal Engine。</p>
   <img src="/2022/01/17/AirSim%E4%BB%BF%E7%9C%9F%E4%B9%8BWindows%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/vs2019_blocks.jpg" class="">

<p>block环境非常简单只有几个正方体和球，当然你也可以在里面做一些其他的操作。点击上方的 “运行”，此时会跳出一个对话框，点击 “No”，就会出现一个四旋翼（如果是点击的 “Yes”，就会出现一个小车），如下图所示。如果出现了四旋翼（或者小车），则证明 AirSim 环境配置成功。</p>
   <img src="/2022/01/17/AirSim%E4%BB%BF%E7%9C%9F%E4%B9%8BWindows%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ue_blocks.jpg" class="">

<p>AirSim的配置文件位于C:\Users$YOUR USER NAME$\Documents\AirSim\settings.json文件中。将”SimMode”改为”Multirotor”就会采用四旋翼仿真。</p>
<h1 id="免安装Epic，UE环境，直接使用"><a href="#免安装Epic，UE环境，直接使用" class="headerlink" title="免安装Epic，UE环境，直接使用"></a>免安装Epic，UE环境，直接使用</h1><ul>
<li>从AirSim的Release中下载编译好的UE4环境，如<code>Blocks.zip</code>，并解压。</li>
<li>在<code>解压位置\Blocks\WindowsNoEditor</code>中找到<code>Blocks.exe</code>双击运行</li>
<li>初次运行可能需要安装<code>DirectX Runtime</code>，可以从<a href="https://www.microsoft.com/en-hk/download/details.aspx?id=35">这里</a>下载</li>
<li>初次运行时可以选择<strong>Car</strong>或者<strong>Multirotor</strong>，后续可以在Setting中进行修改指定一种</li>
<li>Press <code>F1</code>可以看到设置，<code>Alt+Enter</code>可以切换全屏/窗口模式</li>
</ul>
<ul>
<li>关于settings.json文件配置<ul>
<li>ref1: <a href="https://microsoft.github.io/AirSim/settings/">https://microsoft.github.io/AirSim/settings/</a></li>
</ul>
</li>
<li>体验<ul>
<li>安装airsim python包：<code>pip install airsim</code>， 显示<code>Successfully installed airsim-1.3.0 msgpack-python-0.5.6 msgpack-rpc-python-0.4.1 opencv-contrib-python-4.5.1.48 tornado-4.5.3</code></li>
<li>运行<code>Blocks.exe</code></li>
<li>运行<code>hello_drone.py</code></li>
<li>其他示例代码：<a href="https://github.com/microsoft/AirSim/tree/master/PythonClient/multirotor">https://github.com/microsoft/AirSim/tree/master/PythonClient/multirotor</a></li>
</ul>
</li>
<li>注意<ul>
<li>有时候会出现连接不上的情况，需要关掉UE4环境，并从任务管理器中结束所有UE4的进程，再重新打开环境进行连接</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>AirSim仿真</category>
      </categories>
      <tags>
        <tag>仿真</tag>
        <tag>Simulation</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub加速方法</title>
    <url>/2022/01/17/github%E5%8A%A0%E9%80%9F%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本文旨在解决git clone ，直接下载ZIP文件，以及Release中的asset文件速度慢的问题。</p>
<span id="more"></span>
<h1 id="1-GitHub镜像访问"><a href="#1-GitHub镜像访问" class="headerlink" title="1. GitHub镜像访问"></a>1. GitHub镜像访问</h1><p>这里提供一个常用的镜像地址：</p>
<ul>
<li><a href="https://hub.fastgit.org/">https://hub.fastgit.org</a></li>
</ul>
<p>此网站是 GitHub 的镜像，适合在 GitHub 也无法登陆的时候可以使用。可以在此进行下载克隆等操作。</p>
<h1 id="2-油猴插件"><a href="#2-油猴插件" class="headerlink" title="2. 油猴插件"></a>2. 油猴插件</h1><p>油猴借助网页的scripts，能够实现对网页的定制化修改。能够实现诸如去广告，自动完成验证码，免登录看视频，跳过视频片头，解析视频链接，下载视频等等诸多功能。这里列举的只是九牛一毛。使用油猴加速的原理是将下载(clone)的地址修改为镜像的地址，从而实现加速。</p>
<h2 id="2-1插件安装"><a href="#2-1插件安装" class="headerlink" title="2.1插件安装"></a>2.1插件安装</h2><p>首先要给浏览器安装油猴插件</p>
<h3 id="2-1-1-Chrome"><a href="#2-1-1-Chrome" class="headerlink" title="2.1.1 Chrome"></a>2.1.1 Chrome</h3><p>Chrome插件有两种方式可以下载</p>
<ul>
<li>从商城中下载。（需要科学上网）</li>
<li>进入开发者模式，从内网下载插件后自己安装。</li>
</ul>
<h3 id="2-1-2-360极速浏览器"><a href="#2-1-2-360极速浏览器" class="headerlink" title="2.1.2 360极速浏览器"></a>2.1.2 360极速浏览器</h3><p>在地址栏中输入 <a href="https://ext.chrome.360.cn/">https://ext.chrome.360.cn/</a> 搜索<strong>暴力猴ViolentMonkey</strong>安装即可。</p>
<h3 id="2-1-3-Edge浏览器"><a href="#2-1-3-Edge浏览器" class="headerlink" title="2.1.3 Edge浏览器"></a>2.1.3 Edge浏览器</h3><p>在地址栏中输入 <a href="https://microsoftedge.microsoft.com/addons/Microsoft-Edge-Extensions-Home">https://microsoftedge.microsoft.com/addons/Microsoft-Edge-Extensions-Home</a>  搜索 Tampermonkey 安装即可。</p>
<h2 id="2-2-使用加速脚本"><a href="#2-2-使用加速脚本" class="headerlink" title="2.2 使用加速脚本"></a>2.2 使用加速脚本</h2><p><a href="https://greasyfork.org/">https://greasyfork.org</a>  是一个油猴脚本的发布站，里面有许多奇奇怪怪的脚本可用。这里我们直接使用 <a href="https://greasyfork.org/scripts/412245">https://greasyfork.org/scripts/412245</a> 脚本下载安装即可。</p>
<h2 id="2-3-油猴效果"><a href="#2-3-油猴效果" class="headerlink" title="2.3 油猴效果"></a>2.3 油猴效果</h2><p>安装后效果如下所示</p>
<img src="/2022/01/17/github%E5%8A%A0%E9%80%9F%E6%96%B9%E6%B3%95/github_download.jpg" class="">

<h1 id="3-构造链接下载"><a href="#3-构造链接下载" class="headerlink" title="3 构造链接下载"></a>3 构造链接下载</h1><p>在要下载的路径前加 <a href="https://gh.api.99988866.xyz/">https://gh.api.99988866.xyz/</a> 即可。<br>例如要下载 <a href="https://github.com/xxxx/archive/master.zip">https://github.com/xxxx/archive/master.zip</a> 文件，只需构造新的URL:<a href="https://gh.api.99988866.xyz/https://github.com/xxxx/archive/master.zip">https://gh.api.99988866.xyz/https://github.com/xxxx/archive/master.zip</a> ，输入到地址栏中即可开始下载。</p>
<h1 id="4-Gitee"><a href="#4-Gitee" class="headerlink" title="4 Gitee"></a>4 Gitee</h1><p>直接在Gitee中搜索下载。如果Gitee中没有，需要自己新建仓库从GitHub中导入。<br>这种方法比较麻烦，而且实时性不好。</p>
<h1 id="5-走代理-amp-改hosts"><a href="#5-走代理-amp-改hosts" class="headerlink" title="5 走代理 &amp; 改hosts"></a>5 走代理 &amp; 改hosts</h1><p>以上方法均不解决clone时带有submodule的仓库。若是需要clone带submodule的仓库要么开代理，要么改hosts文件。<br>可以在电脑上或者路由器上配置代理，从而实现走代理下载。<br>一劳永逸，就是比较麻烦，有时还需要RMB。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>git</tag>
      </tags>
  </entry>
</search>
