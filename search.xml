<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基金基础知识</title>
    <url>/2022/02/20/%E5%9F%BA%E9%87%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="1-基金分类方法"><a href="#1-基金分类方法" class="headerlink" title="1 基金分类方法"></a>1 基金分类方法</h3><h4 id="1-1-按照投资品种分类"><a href="#1-1-按照投资品种分类" class="headerlink" title="1.1 按照投资品种分类"></a>1.1 按照投资品种分类</h4><ul>
<li><p><strong>股票型基金</strong>：①80%以上的资产投资于股票。②收益最高。③风险最大。</p>
</li>
<li><p><strong>混合型（偏股，偏债）基金</strong>：①一般股票60%，债券20%，货币20%。②收益率比债券基金高。③风险也比债券基金高。</p>
</li>
<li><p><strong>债券型基金</strong>：①80%以上的资产投资于债券。②收益率比货币基金高。③风险也比货币基金高。</p>
</li>
<li><p><strong>货币型基金</strong>：①基金资产仅投资于货币市场（银行存单，央票等）。②收益率较低，但是比活期存款高。③风险相对较小。</p>
<img src="/2022/02/20/%E5%9F%BA%E9%87%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/risk_profit.jpg" class=""></li>
</ul>
<h4 id="1-2-按照投资方式分类"><a href="#1-2-按照投资方式分类" class="headerlink" title="1.2 按照投资方式分类"></a>1.2 按照投资方式分类</h4><ul>
<li><strong>被动性基金（指数基金）</strong>：按照构成指数的成分股配置。申购费比较低。</li>
<li><strong>主动型基金</strong>：由基金经理来选股，选债。申购费较高</li>
</ul>
<h4 id="1-3-基金运作方式分类"><a href="#1-3-基金运作方式分类" class="headerlink" title="1.3 基金运作方式分类"></a>1.3 基金运作方式分类</h4><ul>
<li><strong>开放式基金</strong>：随时可以买入或者卖出</li>
<li><strong>封闭式基金</strong>：封闭期内基金份额不变，必须在证券交易场购买（场内购买）。</li>
</ul>
<h4 id="1-4-按购买渠道分类"><a href="#1-4-按购买渠道分类" class="headerlink" title="1.4 按购买渠道分类"></a>1.4 按购买渠道分类</h4><ul>
<li><strong>场内基金</strong>：放在证券交易所里买卖的基金。操作起来与买卖股票是一样的。例如同花顺，东方财富等平台。</li>
<li><strong>场外基金</strong>：在证券交易所外买卖的基金。</li>
</ul>
<p>  ​    两者有以下几个区别：</p>
<p>  <strong>交易价格：</strong>场内基金的交易与股票类似，实时买入卖出。场外基金一天只有一个价格。如果在下午三点前买入，则按照当日交易结束时的价格结算。三点后购买，按照第二个交易日结束时价格结算。</p>
<h3 id="2-晨星星级评定"><a href="#2-晨星星级评定" class="headerlink" title="2 晨星星级评定"></a>2 晨星星级评定</h3><p>  晨星网的评级反映了一只基金能给投资者带来的<strong>回报与自身风险</strong>之间的关系。对购买基金有较好的参考作用。</p>
  <img src="/2022/02/20/%E5%9F%BA%E9%87%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/morningstar.jpg" class="">

<h3 id="3-基金买卖过程中的成本"><a href="#3-基金买卖过程中的成本" class="headerlink" title="3 基金买卖过程中的成本"></a>3 基金买卖过程中的成本</h3><p>  ​    基金购买过程的费用主要包含四种：<strong>申购费、赎回费、管理费、托管费</strong>。不同的购买渠道，费用相差比较大。下面介绍几种购买方式：</p>
<ul>
<li><p>银行代销：<strong>货币型基金</strong>没有申购费，债券型基金申购费0.6%-0.8%。<strong>股票型基金</strong>1%-1.5%。</p>
</li>
<li><p>基金公司：申购费常常打折。基金转换时只需要补申购费差价。但是只能购买本基金公司的产品。</p>
</li>
<li><p>第三方基金代销平台：常见的有天天基金，支付宝等。申购费最低，品种比较齐全。</p>
<img src="/2022/02/20/%E5%9F%BA%E9%87%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/funds_fee.jpg" class="">

<p>可以看到，管理费，托管费在净值公布时就已经扣除了。赎回的费率一般时间越长费率越低。大多数情况下，申购费一般会打一折甚至免费。下图列出了不同类型基金的费用。</p>
<img src="/2022/02/20/%E5%9F%BA%E9%87%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/fees.jpg" class=""></li>
</ul>
<h3 id="4-评价基金的指标"><a href="#4-评价基金的指标" class="headerlink" title="4 评价基金的指标"></a>4 评价基金的指标</h3><h4 id="4-1-策略总收益（Total-Returns）"><a href="#4-1-策略总收益（Total-Returns）" class="headerlink" title="4.1 策略总收益（Total Returns）"></a>4.1 策略总收益（Total Returns）</h4><p>$$<br>\text { Total Returns }=\frac{P V_{\text {end }}-P V_{\text {start }}}{P V_{\text {start }}} * 100<br>$$</p>
<p>$PV_{end}$：最终总价值</p>
<p>$PV_{start}$：开始总价值</p>
<h4 id="4-2-年化收益率（Annualized-Returns）"><a href="#4-2-年化收益率（Annualized-Returns）" class="headerlink" title="4.2 年化收益率（Annualized Returns）"></a>4.2 年化收益率（Annualized Returns）</h4><p>策略年化收益率。表示投资期限为一年的预期收益率。<br>$$<br>\text { Total Annualized Returns }=R_{p}=\left((1+P)^{\frac{252}{n}}-1\right) * 100<br>$$<br>$P$：策略总收益</p>
<p>$n$：策略执行天数</p>
<h4 id="4-3-波动率（Volatility）"><a href="#4-3-波动率（Volatility）" class="headerlink" title="4.3 波动率（Volatility）"></a>4.3 波动率（Volatility）</h4><p>  基金投资回报率的波动程度，体现为策略每日收益的年化标准差 。<br>$$<br>\text { Volatility }=\sigma_{p}=\sqrt{\frac{252}{n} \sum_{i}^{n}\left(R_{p}-\overline{R_{p}}\right)^{2}}<br>$$<br>$R_p$：策略总收益</p>
<p>$\overline{R_{p}}$：策略每日收益率平均值</p>
<p>$n$：策略执行天数</p>
<h4 id="4-4-最大回撤（Max-Drawdown）"><a href="#4-4-最大回撤（Max-Drawdown）" class="headerlink" title="4.4 最大回撤（Max Drawdown）"></a>4.4 最大回撤（Max Drawdown）</h4><p>基金收益率回撤幅度的最大值。描述策略可能出现的最糟糕的情况。</p>
<p>$$<br>\text { Max Drawdown }=\frac{\operatorname{Max}\left(P_{x}-P_{y}\right)}{P_{x}}<br>$$<br>$P_x,P_y$：某日总价值，且$y&gt;x$</p>
<h4 id="4-5-夏普比率（Sharpe-Ratio）"><a href="#4-5-夏普比率（Sharpe-Ratio）" class="headerlink" title="4.5 夏普比率（Sharpe Ratio）"></a>4.5 夏普比率（Sharpe Ratio）</h4><p>投资光看收益是不够的，还要看承受的风险，也就是收益风险比。夏普比率描述的正是这个概念，即每承受一单位的总风险，会产生多少超额的报酬。用数学公式描述就是：<br>$$<br>\text { Sharpe Ratio }=\frac{\left(R_{p}-R_{f}\right)}{\sigma_{p}}<br>$$<br>$R_{p}$：投资组合预期收益率（各种年化利率）</p>
<p>$R_f$：无风险利率（十年期国债利率，或默认0.03）</p>
<p>$\sigma_{p}$：年化波动率</p>
<h4 id="4-6-信息比率（Information-Ratio）"><a href="#4-6-信息比率（Information-Ratio）" class="headerlink" title="4.6 信息比率（Information Ratio）"></a>4.6 信息比率（Information Ratio）</h4><p>衡量单位超额风险带来的超额收益。信息比率越大，说明该策略单位跟踪误差所获得的超额收益越高，因此，信息比率较大的策略的表现要优于信息比率较低的基准。合理的投资目标应该是在承担适度风险下，尽可能追求高信息比率。<br>$$<br>\text { Sharpe Ratio }=\frac{\left(R_{p}-R_{m}\right)}{\sigma_{t}}<br>$$<br>$R_{p}$：投资组合预期收益率（各种年化利率）</p>
<p>$R_m$：基准年化收益率</p>
<p>$\sigma_{t}$：策略与基准每日收益差值的年化标准差</p>
<h4 id="4-7-阿尔法（Alpha）"><a href="#4-7-阿尔法（Alpha）" class="headerlink" title="4.7 阿尔法（Alpha）"></a>4.7 阿尔法（Alpha）</h4><p>投资中面临着系统性风险（即Beta）和非系统性风险（即Alpha），Alpha 是投资者获得与市场波动无关的回报。比如投资者获得了15%的回报，其基准获得了10%的回报，那么Alpha 或者价值增值的部分就是5%。<br>$$<br>\text { Alpha }=\alpha=R_{p}-\left(R_{f}+\beta_{p}\left(R_{m}-R_{f}\right)\right)<br>$$<br>$R_{p}$：策略年化收益率</p>
<p>$R_m$：基准年化收益率（？？）</p>
<p>$R_f$：无风险利率（十年期国债，或者默认0.03）</p>
<p>$\beta_{p}$：策略Beta值</p>
<p>Alpha值解释</p>
<p>α&gt;0 策略相对于市场，获得了超额收益<br>α=0 策略相对于市场，获得了适当收益<br>α&lt;0 策略相对于市场，获得了较少收益</p>
<h4 id="4-8-贝塔（Beta）"><a href="#4-8-贝塔（Beta）" class="headerlink" title="4.8 贝塔（Beta）"></a>4.8 贝塔（Beta）</h4><p>表示投资的系统性风险，反映了策略对大盘变化的敏感性。例如一个策略的Beta为1.5，则大盘涨1%的时候，策略可能涨1.5%，反之亦然；如果一个策略的Beta为-1.5，说明大盘涨1%的时候，策略可能跌1.5%，反之亦然。<br>$$<br>\operatorname{Beta}=\beta_{p}=\frac{\operatorname{Cov}\left(D_{p}, D_{m}\right)}{\operatorname{Var}\left(D_{m}\right)}<br>$$<br>$D_{p}$：策略每日收益率</p>
<p>$D_m$：基准每日收益率（？？）</p>
<p>$Cov(D_p,D_m)$：策略每日收益与基准每日收益的协方差</p>
<p>$Var{D_m}$：基准每日收益的方差</p>
<p>Beta值解释</p>
<p>β&lt;0 投资组合和基准的走向通常反方向，如空头头寸类</p>
<p>β=0 投资组合和基准的走向没有相关性，如固定收益类</p>
<p>0&lt;β&lt;1 投资组合和基准的走向相同，但是比基准的移动幅度更小</p>
<p>β=1 投资组合和基准的走向相同，并且和基准的移动幅度贴近</p>
<p>β&gt;1 投资组合和基准的走向相同，但是比基准的移动幅度更大</p>
<h3 id="2-基金特性"><a href="#2-基金特性" class="headerlink" title="2 基金特性"></a>2 基金特性</h3><h3 id="2-1-货币基金"><a href="#2-1-货币基金" class="headerlink" title="2.1 货币基金"></a>2.1 货币基金</h3><p>货币型基金安全性高，基本投资于银行，短债等收益稳定的领域。其次它的流动性好，例如余额宝等能够做到实时转入转出。然后是它的成本比较低，没有申购赎回费用，且管理费用也很低。最后它基本没有投资们开，起购金额低。</p>
<img src="/2022/02/20/%E5%9F%BA%E9%87%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/huobi_yinhang.jpg" class="">

<h4 id="什么样的货币基金值得买？"><a href="#什么样的货币基金值得买？" class="headerlink" title="什么样的货币基金值得买？"></a>什么样的货币基金值得买？</h4><p>一般来说，购买或货币基金考虑以下几个方面：<br>① 收益率：货币基金一般参考万份收益率和七天年化收益率。优先购买收益率高的。<br>② 购买规模适中：考虑到船大难掉头，一般来说中等规模（50-300亿，2018年数据。）的货币基金收益率最高。<br>③ 基金安全性：基金中散户比例高的流动性非常低，因此比较稳健。购买时散户比例最好不好低于20%。<br>④ 成立时间：较新的基金数据时间较短数据参考价值不高，而能够横穿牛熊的老牌基金更有参考价值，更为稳健。一般成立时间3-5年以上的比较好。</p>
<h4 id="申购赎回注意项"><a href="#申购赎回注意项" class="headerlink" title="申购赎回注意项"></a>申购赎回注意项</h4><p>①周五不买入，周四不赎回。尽量在下午三点前操作。<br>②节假日货币基金也有收益，可以提前申购。<br>③货币基金在同一家基金公司可以转换成股票基金或者混合基金。转换只收取申购赎回的差额费用。</p>
<h3 id="2-2-债券基金"><a href="#2-2-债券基金" class="headerlink" title="2.2 债券基金"></a>2.2 债券基金</h3><h4 id="债券的类别"><a href="#债券的类别" class="headerlink" title="债券的类别"></a>债券的类别</h4><ul>
<li><strong>政府债券</strong>：比如中央政府发行的债券，叫国债。</li>
<li>金融机构债券：比如银行向社会发行的债券叫做金融债。信用比企业信用高。</li>
<li><strong>企业债券</strong>：企业自己发行的债券，信用没有前两个高。<br>债券的灵活性极差，购买后想卖出需要找到买家。</li>
</ul>
<h4 id="债券基金"><a href="#债券基金" class="headerlink" title="债券基金"></a>债券基金</h4><p>建议长期持有，存在亏损可能。收益率一般在5%以下。</p>
<img src="/2022/02/20/%E5%9F%BA%E9%87%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/bonds.jpg" class="">

<h4 id="什么样的债券基金值得买？"><a href="#什么样的债券基金值得买？" class="headerlink" title="什么样的债券基金值得买？"></a>什么样的债券基金值得买？</h4><ul>
<li>收益率高低。</li>
<li>基金公司是否是大公司。（银行系的基金公司可能拿到成本更低的债券，名字例如工银瑞信双利债券A）</li>
<li>晨星评级。</li>
<li>购买基金时的费用。</li>
<li>基金规模最好在50-500亿</li>
</ul>
<h4 id="什么时候适合投资债券基金？"><a href="#什么时候适合投资债券基金？" class="headerlink" title="什么时候适合投资债券基金？"></a>什么时候适合投资债券基金？</h4><ul>
<li>降息降准。货币政策宽松能促进债券型基金收益上升。</li>
<li>股市低迷。股票市场进入熊市时，债券基金收益较好</li>
</ul>
<h3 id="2-3-混合型基金与股票型基金"><a href="#2-3-混合型基金与股票型基金" class="headerlink" title="2.3 混合型基金与股票型基金"></a>2.3 混合型基金与股票型基金</h3><p>混合型基金分为四类：偏股型，偏债型，平衡型和配置型。从字面意思就能看出来各种类型的风险和收益。股票型基金要求股票占比必须在80%以上。风险和收益都是最高的。</p>
<h4 id="什么样的混合型基金值得买？"><a href="#什么样的混合型基金值得买？" class="headerlink" title="什么样的混合型基金值得买？"></a>什么样的混合型基金值得买？</h4><p><strong>粗看：</strong></p>
<p>一般来说挑选混合型基金可以看以下几个流程挑选出3-5只基金：</p>
<p>①先看收益率。先海选三年累计收益率排名前30。再选5只近一年收益率相对较高的。</p>
<p>②选择大公司。比如易方达，博时，南方，嘉实等。</p>
<p>③挑选星级评定4-5星的。</p>
<p>④基金规模在20-150亿之间的，成立时间3-5年的。</p>
<p>⑤从基金经理挑选，具备3-5年管理经验的。</p>
<p>⑥购买费率较低的。</p>
<p><strong>细看</strong>：</p>
<p>①基金经理的能力。混合型基金属于主动型基金，比较考验基金经理的主动投资管理能力。可以从基金经理的星级，综合评分（经验值，收益率，抗风险，稳定性，择时能力等），任期收益等三方面看。</p>
<h3 id="2-4-指数基金"><a href="#2-4-指数基金" class="headerlink" title="2.4 指数基金"></a>2.4 指数基金</h3>]]></content>
      <categories>
        <category>基金知识</category>
      </categories>
      <tags>
        <tag>基金类型</tag>
        <tag>基金购买方法</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下库文件查看依赖的方法</title>
    <url>/2022/01/18/Windows%E4%B8%8B%E5%BA%93%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E4%BE%9D%E8%B5%96%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在Windows上有时候自己编译的EXE或者DLL文件会出现打不开的情况，一个可能的原因是文件缺乏依赖库。网上搜了一下都是推荐 <code>dumpbin</code> 命令，但是这个命令一方面是需要下载Visual Studio，很麻烦，另一方面没有GUI，而且看不到缺哪些库，很难受。还有推荐<code>Depend</code>的，我找了一下，现在Depend已经不更新了，只支持到Win8，在Win10上会卡死。</p>
<span id="more"></span>

<p>这里推荐一个好用的工具叫<code>Dependencies_x64</code>，下载链接<code>https://github.com/lucasg/Dependencies/releases</code></p>
<img src="/2022/01/18/Windows%E4%B8%8B%E5%BA%93%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E4%BE%9D%E8%B5%96%E7%9A%84%E6%96%B9%E6%B3%95/dependencies.png" class="">

<img src="/2022/01/18/Windows%E4%B8%8B%E5%BA%93%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E4%BE%9D%E8%B5%96%E7%9A%84%E6%96%B9%E6%B3%95/dependencies_qglopm.png" class="">

<p>对于库文件的依赖都列在左上角了，然后对于有问题的依赖，或是没找到的依赖都会标红处理。</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Debug</tag>
        <tag>依赖查看</tag>
      </tags>
  </entry>
  <entry>
    <title>AirSim仿真之Python实现无人机控制</title>
    <url>/2022/01/17/AirSim%E4%BB%BF%E7%9C%9F%E4%B9%8BPython%E5%AE%9E%E7%8E%B0%E6%97%A0%E4%BA%BA%E6%9C%BA%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>Python实现AirSim控制</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> airsim</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> pynput <span class="keyword">import</span> keyboard</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QGridLayout, QMainWindow, QAction, QApplication, QWidget, QPushButton, qApp, QLabel, QHBoxLayout, QVBoxLayout, QSplitter</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QIcon, QPixmap, QImage, QMatrix4x4, QQuaternion, QVector3D, QColor, QGuiApplication</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> Qt,QTimer</span><br><span class="line"><span class="keyword">import</span> pyqtgraph <span class="keyword">as</span> pg</span><br><span class="line"><span class="keyword">from</span> pyqtgraph <span class="keyword">import</span> functions <span class="keyword">as</span> fn</span><br><span class="line"><span class="keyword">import</span> pyqtgraph.opengl <span class="keyword">as</span> gl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vel_map=&#123;</span><br><span class="line">            Qt.Key_Left : np.array((<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>)),</span><br><span class="line">            Qt.Key_Right: np.array((<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>)),</span><br><span class="line">            Qt.Key_Up   : np.array((<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)),</span><br><span class="line">            Qt.Key_Down : np.array((-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)),</span><br><span class="line">            Qt.Key_W    : np.array((<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>)),</span><br><span class="line">            Qt.Key_S    : np.array((<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">v_max = <span class="number">100</span>     <span class="comment"># 无人机最大飞行速度</span></span><br><span class="line">v_factor = <span class="number">15</span></span><br><span class="line">r_max = <span class="number">20</span>    <span class="comment"># 邻居选择的半径</span></span><br><span class="line">k_sep = <span class="number">7</span>     <span class="comment"># 控制算法系数</span></span><br><span class="line">k_coh = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">fov_degree = <span class="number">90</span></span><br><span class="line">height = <span class="number">144</span></span><br><span class="line">width = <span class="number">256</span></span><br><span class="line">cx = width/<span class="number">2</span></span><br><span class="line">cy = height/<span class="number">2</span></span><br><span class="line">f = height/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize</span>(<span class="params">v</span>):</span></span><br><span class="line">    norm = np.linalg.norm(v)</span><br><span class="line">    <span class="keyword">if</span> norm &lt; <span class="number">0.00000001</span>: </span><br><span class="line">       <span class="keyword">return</span> v</span><br><span class="line">    <span class="keyword">return</span> v / norm</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">np2qpixmap</span>(<span class="params">np_img</span>):</span></span><br><span class="line">    frame = cv2.cvtColor(np_img, cv2.COLOR_BGR2RGB)</span><br><span class="line">    img = QImage(frame, frame.shape[<span class="number">1</span>], frame.shape[<span class="number">0</span>], QImage.Format_RGB888)</span><br><span class="line">    <span class="keyword">return</span> QPixmap.fromImage(img)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiUAVControl</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MultiUAVControl, self).__init__()</span><br><span class="line">        self.client = airsim.MultirotorClient()</span><br><span class="line">        self.uav_names = self.client.listVehicles()</span><br><span class="line">        self.uav_num = <span class="built_in">len</span>(self.uav_names)</span><br><span class="line">        self.fname  = self.uav_names[-<span class="number">1</span>]</span><br><span class="line">        self.cur_UAV = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getUAVPos</span>(<span class="params">self,vehicle_name=<span class="string">&quot;SimpleFlight&quot;</span></span>):</span></span><br><span class="line">        state = self.client.simGetObjectPose(vehicle_name)</span><br><span class="line">        x = state.position.x_val</span><br><span class="line">        y = state.position.y_val</span><br><span class="line">        z = state.position.z_val</span><br><span class="line">        pos = np.array([x, y,z])</span><br><span class="line">        <span class="keyword">return</span> pos</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setCurUAV</span>(<span class="params">self,uav</span>):</span></span><br><span class="line">        <span class="keyword">if</span> uav &lt;= self.uav_num:</span><br><span class="line">            self.cur_UAV=uav</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">takeOff</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;start to takeoff&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> self.uav_names:</span><br><span class="line">            self.client.enableApiControl(<span class="literal">True</span>, name) </span><br><span class="line">            self.client.armDisarm(<span class="literal">True</span>, name)        </span><br><span class="line">            self.client.takeoffAsync(vehicle_name=name)</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> self.uav_names:</span><br><span class="line">            self.client.moveToZAsync(-<span class="number">3</span>, <span class="number">1</span>, vehicle_name=name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">land</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;start to land&quot;</span>)</span><br><span class="line">        self.client.simPause(<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> self.uav_names:</span><br><span class="line">            self.client.landAsync(vehicle_name=name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveByKeys</span>(<span class="params">self, keys</span>):</span></span><br><span class="line">        base_vel = np.array((<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> keys:</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">in</span> vel_map:</span><br><span class="line">                base_vel+=vel_map[k]</span><br><span class="line">        <span class="keyword">if</span>  np.linalg.norm(base_vel)  &lt;= <span class="number">0.00001</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> name <span class="keyword">in</span> self.uav_names:</span><br><span class="line">                pos_i = self.getUAVPos(name)</span><br><span class="line">                v_mig = v_factor* (base_vel <span class="keyword">if</span> self.cur_UAV == <span class="number">0</span> <span class="keyword">or</span> name == self.uav_names[self.cur_UAV-<span class="number">1</span>] <span class="keyword">else</span> np.zeros(<span class="number">3</span>))</span><br><span class="line">                v_sep = np.zeros(<span class="number">3</span>)</span><br><span class="line">                v_coh = np.zeros(<span class="number">3</span>)</span><br><span class="line">                neighbor = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> name_other <span class="keyword">in</span> self.uav_names:</span><br><span class="line">                    <span class="keyword">if</span> name != name_other:</span><br><span class="line">                        pos_j = self.getUAVPos(name_other)</span><br><span class="line">                        <span class="keyword">if</span> np.linalg.norm(pos_j - pos_i) &lt; r_max:</span><br><span class="line">                            neighbor = neighbor+<span class="number">1</span></span><br><span class="line">                            r_ij = pos_j - pos_i</span><br><span class="line">                            v_sep += -k_sep * r_ij / np.linalg.norm(r_ij)</span><br><span class="line">                            v_coh += k_coh * r_ij</span><br><span class="line">                v_sep = v_sep / <span class="built_in">max</span>(neighbor,<span class="number">1</span>)</span><br><span class="line">                v_coh = v_coh / <span class="built_in">max</span>(neighbor,<span class="number">1</span>)</span><br><span class="line">                vel = v_sep + v_coh + v_mig</span><br><span class="line">                vel = normalize(vel)*<span class="built_in">min</span>(np.linalg.norm(vel),v_max)</span><br><span class="line">                <span class="built_in">print</span>(vel)</span><br><span class="line">                self.client.moveByVelocityBodyFrameAsync(vel[<span class="number">0</span>], vel[<span class="number">1</span>],vel[<span class="number">2</span>],</span><br><span class="line">                                                         <span class="number">0.1</span>,drivetrain = airsim.DrivetrainType.ForwardOnly,</span><br><span class="line">                                                         yaw_mode=airsim.YawMode(is_rate=<span class="literal">False</span>,yaw_or_rate=<span class="number">0</span>),</span><br><span class="line">                                                         vehicle_name=name)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getImage</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        data = self.client.simGetImages([airsim.ImageRequest(<span class="number">0</span>, airsim.ImageType.Scene, <span class="literal">False</span>, <span class="literal">False</span>)],vehicle_name=name)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> np.flipud(np.frombuffer(data.image_data_uint8, dtype=np.uint8).reshape((data.height,data.width,<span class="number">3</span>)))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDepth</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        data = self.client.simGetImages([airsim.ImageRequest(<span class="number">0</span>, airsim.ImageType.DepthPerspective, <span class="literal">True</span>, <span class="literal">False</span>)],vehicle_name=name)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> np.array(data.image_data_float, dtype=np.float32).reshape((data.height,data.width))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDepthAndImage</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        data = self.client.simGetImages([airsim.ImageRequest(<span class="number">0</span>, airsim.ImageType.Scene, <span class="literal">False</span>, <span class="literal">False</span>),</span><br><span class="line">            airsim.ImageRequest(<span class="number">0</span>, airsim.ImageType.DepthPerspective, <span class="literal">True</span>, <span class="literal">False</span>) ],vehicle_name=name)</span><br><span class="line">        image = np.flipud(np.frombuffer(data[<span class="number">0</span>].image_data_uint8, dtype=np.uint8).reshape((data[<span class="number">0</span>].height,data[<span class="number">0</span>].width,<span class="number">3</span>)))</span><br><span class="line">        depth = np.array(data[<span class="number">1</span>].image_data_float, dtype=np.float32).reshape((data[<span class="number">1</span>].height,data[<span class="number">1</span>].width))</span><br><span class="line">        <span class="keyword">return</span> [image,depth]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getImages</span>(<span class="params">self</span>):</span></span><br><span class="line">        images = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> self.uav_names:</span><br><span class="line">            images[name]=self.getImage(name)</span><br><span class="line">        <span class="keyword">return</span> images</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDepthes</span>(<span class="params">self</span>):</span></span><br><span class="line">        images = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> self.uav_names:</span><br><span class="line">            images[name]=self.getDepth(name)</span><br><span class="line">        <span class="keyword">return</span> images</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPointCloudPos</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        data = self.getDepth(name)</span><br><span class="line">        poses=[]</span><br><span class="line">        <span class="keyword">for</span> (x,y),v <span class="keyword">in</span> np.ndenumerate(data):</span><br><span class="line">             poses.append([(x-cx)/f*v,(y-cy)/f*v,v])</span><br><span class="line">        <span class="keyword">return</span> np.array(poses)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPointCloudColor</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        data = self.getImage(name)</span><br><span class="line">        <span class="keyword">return</span> data.reshape((-<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPointCloud</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        [image,depth] = self.getDepthAndImage(name)</span><br><span class="line">        poses=[]</span><br><span class="line">        <span class="keyword">for</span> (x,y),v <span class="keyword">in</span> np.ndenumerate(depth):</span><br><span class="line">             poses.append([(x-cx)/f*v,(y-cy)/f*v,v])</span><br><span class="line">        image = cv2.cvtColor(image,cv2.COLOR_RGB2BGR)</span><br><span class="line">        colors=image.reshape((-<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        <span class="keyword">return</span> [np.array(poses),np.array(colors)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveToPositionAll</span>(<span class="params">self,x, y, z, velocity, </span></span></span><br><span class="line"><span class="params"><span class="function">        timeout_sec=<span class="number">3e+38</span>, drivetrain=<span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">        lookahead=-<span class="number">1</span>, adaptive_lookahead=<span class="number">1</span></span>):</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> self.uav_names:</span><br><span class="line">            <span class="keyword">if</span> name != self.fname:                                  </span><br><span class="line">                self.client.moveToPositionAsync(x, y, z,velocity, timeout_sec=timeout_sec, drivetrain=drivetrain,</span><br><span class="line">        lookahead=lookahead, adaptive_lookahead=adaptive_lookahead, vehicle_name=name)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.client.moveToPositionAsync(x, y, z,velocity, timeout_sec=timeout_sec, drivetrain=drivetrain,</span><br><span class="line">        lookahead=lookahead, adaptive_lookahead=adaptive_lookahead, vehicle_name=name).join()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveByVelocityAll</span>(<span class="params">self,vx, vy, vz, duration, drivetrain=<span class="number">0</span></span>):</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> self.uav_names:</span><br><span class="line">            self.moveByVelocityAsync(vx,vy,vz,duration,drivetrain=drivetrain,vehicle_name=name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveByVelocityOne</span>(<span class="params">self,vx, vy, z, duration, drivetrain=<span class="number">0</span></span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span>(<span class="params">QMainWindow</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.setWindowTitle(<span class="string">&#x27;MyScreen&#x27;</span>)</span><br><span class="line">        self.cur_key = <span class="built_in">set</span>()</span><br><span class="line">        self.uav_control = MultiUAVControl()</span><br><span class="line">        self.func_map=&#123;</span><br><span class="line">            Qt.Key_F : self.uav_control.takeOff,</span><br><span class="line">            Qt.Key_L : self.uav_control.land,</span><br><span class="line">        &#125;</span><br><span class="line">        self.vel_map=&#123;</span><br><span class="line">            Qt.Key_Left : np.array((<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>)),</span><br><span class="line">            Qt.Key_Right: np.array((<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>)),</span><br><span class="line">            Qt.Key_Up   : np.array((<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)),</span><br><span class="line">            Qt.Key_Down : np.array((-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)),</span><br><span class="line">            Qt.Key_W    : np.array((<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>)),</span><br><span class="line">            Qt.Key_S    : np.array((<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        self.initUI()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initUI</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        main_widget =QWidget()</span><br><span class="line">        layout = QGridLayout()</span><br><span class="line">        main_widget.setLayout(layout)</span><br><span class="line">        self.setCentralWidget(main_widget)</span><br><span class="line"></span><br><span class="line">        self.label = QLabel(self)</span><br><span class="line">        self.label.setFocusPolicy(Qt.FocusPolicy.ClickFocus)</span><br><span class="line">        layout.addWidget(self.label, <span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        glViewer = gl.GLViewWidget()</span><br><span class="line">        self.pcdData = gl.GLScatterPlotItem(size=<span class="number">1</span>)</span><br><span class="line">        glViewer.addItem(self.pcdData)</span><br><span class="line">        layout.addWidget(glViewer, <span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        self.timer = QTimer(self) </span><br><span class="line">        self.timer.timeout.connect(self.doMove)</span><br><span class="line">        self.timer.start(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_image</span>(<span class="params">self</span>):</span></span><br><span class="line">        (poses, colors) = self.uav_control.getPointCloud(<span class="string">&#x27;UAV1&#x27;</span>)</span><br><span class="line">        colors = colors/<span class="number">255</span></span><br><span class="line">        colors = np.insert(colors,<span class="number">3</span>,<span class="number">1</span>,axis=<span class="number">1</span>)</span><br><span class="line">        self.pcdData.setData(pos=poses,color=colors)</span><br><span class="line">        v_images = []</span><br><span class="line">        images_map = self.uav_control.getImages()</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> images_map.items():</span><br><span class="line">            v=v.copy()</span><br><span class="line">            v=cv2.putText(v,k,(<span class="number">10</span>,v.shape[<span class="number">0</span>]//<span class="number">2</span>),cv2.FONT_HERSHEY_SIMPLEX,<span class="number">1.2</span>,(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>),<span class="number">2</span>)</span><br><span class="line">            v_images.append(v)</span><br><span class="line">        v_img = cv2.vconcat(v_images)</span><br><span class="line">        pixmap = QPixmap(np2qpixmap(v_img))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pixmap.isNull():</span><br><span class="line">            self.label.setPixmap(pixmap)</span><br><span class="line">            self.label.adjustSize()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doMove</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.uav_control.moveByKeys(self.cur_key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">keyPressEvent</span>(<span class="params">self, event</span>):</span></span><br><span class="line">        key = event.key()</span><br><span class="line">        <span class="keyword">if</span> key == Qt.Key_Escape:</span><br><span class="line">            self.timer.stop()</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.vel_map:</span><br><span class="line">            self.cur_key.add(key)</span><br><span class="line">        <span class="keyword">elif</span> key &gt;= Qt.Key_0 <span class="keyword">and</span> key &lt;= Qt.Key_9:</span><br><span class="line">            self.uav_control.setCurUAV(key-Qt.Key_0)</span><br><span class="line">        <span class="keyword">elif</span> key <span class="keyword">in</span> self.func_map:</span><br><span class="line">            self.func_map[key]()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">keyReleaseEvent</span>(<span class="params">self, event</span>):</span></span><br><span class="line">        key=event.key()</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.vel_map:</span><br><span class="line">            self.cur_key.remove(key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    ex = App()</span><br><span class="line">    ex.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AirSim仿真</category>
      </categories>
      <tags>
        <tag>仿真</tag>
        <tag>Simulation</tag>
      </tags>
  </entry>
  <entry>
    <title>AirSim仿真之创建自己的仿真环境</title>
    <url>/2022/01/17/AirSim%E4%BB%BF%E7%9C%9F%E4%B9%8B%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>本章旨在使用UE创建自己的仿真环境<br>请参考<a href="https://microsoft.github.io/AirSim/unreal_custenv/">https://microsoft.github.io/AirSim/unreal_custenv/</a></p>
]]></content>
      <categories>
        <category>AirSim仿真</category>
      </categories>
      <tags>
        <tag>仿真</tag>
        <tag>Simulation</tag>
      </tags>
  </entry>
  <entry>
    <title>AirSim仿真之Windows环境搭建</title>
    <url>/2022/01/17/AirSim%E4%BB%BF%E7%9C%9F%E4%B9%8BWindows%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>本文旨在介绍AirSim在Windows下的环境配置流程。</p>
<span id="more"></span>

<h1 id="1-AirSim环境要求"><a href="#1-AirSim环境要求" class="headerlink" title="1. AirSim环境要求"></a>1. AirSim环境要求</h1><ul>
<li>在开始前先把以下环境配置好<ul>
<li>Windows 10+</li>
<li>Python 3.7+</li>
<li>Visual Studio 2019</li>
<li>CMake 3.9+</li>
<li>Epic Game Launcher</li>
</ul>
</li>
<li>AirSim<ul>
<li>Doc：<a href="https://microsoft.github.io/AirSim/">https://microsoft.github.io/AirSim/</a></li>
<li>Github: <a href="https://github.com/microsoft/AirSim">https://github.com/microsoft/AirSim</a></li>
<li>Environment: <a href="https://github.com/Microsoft/AirSim/releases">https://github.com/Microsoft/AirSim/releases</a></li>
</ul>
</li>
</ul>
<h1 id="2-安装虚幻引擎"><a href="#2-安装虚幻引擎" class="headerlink" title="2. 安装虚幻引擎"></a>2. 安装虚幻引擎</h1><ol>
<li>从<a href="https://www.unrealengine.com/download">Epic</a>官网下载新版的Epic客户端。下载完之后需要注册E宝账号。E宝的游戏促销力度很大，经常会免费送游戏，值得一下。</li>
<li>打开Epic，选中左侧的虚幻引擎（UnrealEngine ，UE）标签，再点击右侧的安装，选中<code>4.25版</code>安装。虽然有些仿真景观对UE版本有要求，但是实际上并不严格，不同版本也能兼容。</li>
</ol>
<img src="/2022/01/17/AirSim%E4%BB%BF%E7%9C%9F%E4%B9%8BWindows%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/epic_game.png" class="">

<h1 id="3-编译-AirSim"><a href="#3-编译-AirSim" class="headerlink" title="3. 编译 AirSim"></a>3. 编译 AirSim</h1><ol>
<li><p>将Windows升级到最新更新版。</p>
</li>
<li><p>下载AirSim。从 <a href="https://github.com/Microsoft/AirSim/releases">https://github.com/Microsoft/AirSim/releases</a> 中下载1.6.0版本的AirSim for windows。并解压到某一路径。</p>
</li>
<li><p>打开<code>Developer Command Prompt for VS 2019</code>，cd到刚刚解压的目录下，输入 build.cmd 。这里程序会自动从GitHub上下载<code>rpclib</code>和<code>car_assets</code>两个文件，若是下载失败可以手动下载然后移动到相应位置。</p>
<ul>
<li><p><a href="https://github.com/rpclib/rpclib/archive/v2.2.1.zip">点击此处获得rpclib地址</a></p>
</li>
<li><p><a href="https://github.com/Microsoft/AirSim/releases/download/v1.2.0/car_assets.zip">点击此处获得car_assets地址</a></p>
<p>将手动下载的<code>rpclib-2.2.1</code>重命名为 <code>rpclib.zip</code> 扔到 <code>external\rpclib.zip</code> 下。解压 <code>car_assert.zip</code> 的 <code>SUV</code> 文件夹到 <code>Unreal\Plugins\AirSim\Content\VehicleAdv\</code>。最后重新运行<code>build.cmd</code>。</p>
</li>
</ul>
</li>
<li><p>顺利的话，此时AirSim源码已经编译成功了。</p>
</li>
</ol>
<h1 id="4-测试Block环境"><a href="#4-测试Block环境" class="headerlink" title="4. 测试Block环境"></a>4. 测试Block环境</h1><p>本节参考 <a href="https://zhuanlan.zhihu.com/p/267321662">https://zhuanlan.zhihu.com/p/267321662</a></p>
<p>block环境是airsim自带嵌入的一个Unreal工程文件，可以测试Unreal和airsim是否安装配置成功。打开 “Developer Command Prompt for VS 2019”，进入 “Airsim\Unreal\Environments\Blocks” 文件夹下。进入文件夹的指令是 <code>CD Airsim\Unreal\Environments\Blocks</code>。然后运行指令 <code>update_from_git.bat</code>。运行完成之后，会在 “Airsim\Unreal\Environments\Blocks” 文件夹下生成 “Blocks.sln” 工程文件，如下图所示，双击打开此工程文件，会自动运行 Visual Studio 2019。</p>
   <img src="/2022/01/17/AirSim%E4%BB%BF%E7%9C%9F%E4%B9%8BWindows%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/blocks.jpg" class="">

<p>在Visual Studio 2019中，将 “Block工程” 设为启动项目，编译选项设为 “DebugGame_Editor” 和 “Win64”，然后点击 “调试” -&gt; “开始调试”，如下图所示，这时就会打开Unreal Engine。</p>
   <img src="/2022/01/17/AirSim%E4%BB%BF%E7%9C%9F%E4%B9%8BWindows%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/vs2019_blocks.jpg" class="">

<p>block环境非常简单只有几个正方体和球，当然你也可以在里面做一些其他的操作。点击上方的 “运行”，此时会跳出一个对话框，点击 “No”，就会出现一个四旋翼（如果是点击的 “Yes”，就会出现一个小车），如下图所示。如果出现了四旋翼（或者小车），则证明 AirSim 环境配置成功。</p>
   <img src="/2022/01/17/AirSim%E4%BB%BF%E7%9C%9F%E4%B9%8BWindows%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ue_blocks.jpg" class="">

<p>AirSim的配置文件位于C:\Users$YOUR USER NAME$\Documents\AirSim\settings.json文件中。将”SimMode”改为”Multirotor”就会采用四旋翼仿真。</p>
<h1 id="免安装Epic，UE环境，直接使用"><a href="#免安装Epic，UE环境，直接使用" class="headerlink" title="免安装Epic，UE环境，直接使用"></a>免安装Epic，UE环境，直接使用</h1><ul>
<li>从AirSim的Release中下载编译好的UE4环境，如<code>Blocks.zip</code>，并解压。</li>
<li>在<code>解压位置\Blocks\WindowsNoEditor</code>中找到<code>Blocks.exe</code>双击运行</li>
<li>初次运行可能需要安装<code>DirectX Runtime</code>，可以从<a href="https://www.microsoft.com/en-hk/download/details.aspx?id=35">这里</a>下载</li>
<li>初次运行时可以选择<strong>Car</strong>或者<strong>Multirotor</strong>，后续可以在Setting中进行修改指定一种</li>
<li>Press <code>F1</code>可以看到设置，<code>Alt+Enter</code>可以切换全屏/窗口模式</li>
</ul>
<ul>
<li>关于settings.json文件配置<ul>
<li>ref1: <a href="https://microsoft.github.io/AirSim/settings/">https://microsoft.github.io/AirSim/settings/</a></li>
</ul>
</li>
<li>体验<ul>
<li>安装airsim python包：<code>pip install airsim</code>， 显示<code>Successfully installed airsim-1.3.0 msgpack-python-0.5.6 msgpack-rpc-python-0.4.1 opencv-contrib-python-4.5.1.48 tornado-4.5.3</code></li>
<li>运行<code>Blocks.exe</code></li>
<li>运行<code>hello_drone.py</code></li>
<li>其他示例代码：<a href="https://github.com/microsoft/AirSim/tree/master/PythonClient/multirotor">https://github.com/microsoft/AirSim/tree/master/PythonClient/multirotor</a></li>
</ul>
</li>
<li>注意<ul>
<li>有时候会出现连接不上的情况，需要关掉UE4环境，并从任务管理器中结束所有UE4的进程，再重新打开环境进行连接</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>AirSim仿真</category>
      </categories>
      <tags>
        <tag>仿真</tag>
        <tag>Simulation</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub加速方法</title>
    <url>/2022/01/17/github%E5%8A%A0%E9%80%9F%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>本文旨在解决git clone ，直接下载ZIP文件，以及Release中的asset文件速度慢的问题。</p>
<span id="more"></span>
<h1 id="1-GitHub镜像访问"><a href="#1-GitHub镜像访问" class="headerlink" title="1. GitHub镜像访问"></a>1. GitHub镜像访问</h1><p>这里提供一个常用的镜像地址：</p>
<ul>
<li><a href="https://hub.fastgit.org/">https://hub.fastgit.org</a></li>
</ul>
<p>此网站是 GitHub 的镜像，适合在 GitHub 也无法登陆的时候可以使用。可以在此进行下载克隆等操作。</p>
<h1 id="2-油猴插件"><a href="#2-油猴插件" class="headerlink" title="2. 油猴插件"></a>2. 油猴插件</h1><p>油猴借助网页的scripts，能够实现对网页的定制化修改。能够实现诸如去广告，自动完成验证码，免登录看视频，跳过视频片头，解析视频链接，下载视频等等诸多功能。这里列举的只是九牛一毛。使用油猴加速的原理是将下载(clone)的地址修改为镜像的地址，从而实现加速。</p>
<h2 id="2-1插件安装"><a href="#2-1插件安装" class="headerlink" title="2.1插件安装"></a>2.1插件安装</h2><p>首先要给浏览器安装油猴插件</p>
<h3 id="2-1-1-Chrome"><a href="#2-1-1-Chrome" class="headerlink" title="2.1.1 Chrome"></a>2.1.1 Chrome</h3><p>Chrome插件有两种方式可以下载</p>
<ul>
<li>从商城中下载。（需要科学上网）</li>
<li>进入开发者模式，从内网下载插件后自己安装。</li>
</ul>
<h3 id="2-1-2-360极速浏览器"><a href="#2-1-2-360极速浏览器" class="headerlink" title="2.1.2 360极速浏览器"></a>2.1.2 360极速浏览器</h3><p>在地址栏中输入 <a href="https://ext.chrome.360.cn/">https://ext.chrome.360.cn/</a> 搜索<strong>暴力猴ViolentMonkey</strong>安装即可。</p>
<h3 id="2-1-3-Edge浏览器"><a href="#2-1-3-Edge浏览器" class="headerlink" title="2.1.3 Edge浏览器"></a>2.1.3 Edge浏览器</h3><p>在地址栏中输入 <a href="https://microsoftedge.microsoft.com/addons/Microsoft-Edge-Extensions-Home">https://microsoftedge.microsoft.com/addons/Microsoft-Edge-Extensions-Home</a>  搜索 Tampermonkey 安装即可。</p>
<h2 id="2-2-使用加速脚本"><a href="#2-2-使用加速脚本" class="headerlink" title="2.2 使用加速脚本"></a>2.2 使用加速脚本</h2><p><a href="https://greasyfork.org/">https://greasyfork.org</a>  是一个油猴脚本的发布站，里面有许多奇奇怪怪的脚本可用。这里我们直接使用 <a href="https://greasyfork.org/scripts/412245">https://greasyfork.org/scripts/412245</a> 脚本下载安装即可。</p>
<h2 id="2-3-油猴效果"><a href="#2-3-油猴效果" class="headerlink" title="2.3 油猴效果"></a>2.3 油猴效果</h2><p>安装后效果如下所示</p>
<img src="/2022/01/17/github%E5%8A%A0%E9%80%9F%E6%96%B9%E6%B3%95/github_download.jpg" class="">

<h1 id="3-构造链接下载"><a href="#3-构造链接下载" class="headerlink" title="3 构造链接下载"></a>3 构造链接下载</h1><p>在要下载的路径前加 <a href="https://gh.api.99988866.xyz/">https://gh.api.99988866.xyz/</a> 即可。<br>例如要下载 <a href="https://github.com/xxxx/archive/master.zip">https://github.com/xxxx/archive/master.zip</a> 文件，只需构造新的URL:<a href="https://gh.api.99988866.xyz/https://github.com/xxxx/archive/master.zip">https://gh.api.99988866.xyz/https://github.com/xxxx/archive/master.zip</a> ，输入到地址栏中即可开始下载。</p>
<h1 id="4-Gitee"><a href="#4-Gitee" class="headerlink" title="4 Gitee"></a>4 Gitee</h1><p>直接在Gitee中搜索下载。如果Gitee中没有，需要自己新建仓库从GitHub中导入。<br>这种方法比较麻烦，而且实时性不好。</p>
<h1 id="5-走代理-amp-改hosts"><a href="#5-走代理-amp-改hosts" class="headerlink" title="5 走代理 &amp; 改hosts"></a>5 走代理 &amp; 改hosts</h1><p>以上方法均不解决clone时带有submodule的仓库。若是需要clone带submodule的仓库要么开代理，要么改hosts文件。<br>可以在电脑上或者路由器上配置代理，从而实现走代理下载。<br>一劳永逸，就是比较麻烦，有时还需要RMB。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>git</tag>
      </tags>
  </entry>
</search>
